package module

// Autogenerated file

import (
	"fmt"
	"github.com/weakpixel/aig/pkg/types"
)

func init() {
	addModuleFactory("pip", func() types.Module {
		return NewPip()
	})
}

//
// Pip (pip) - Manages Python library dependencies
//
func NewPip() *Pip {
	module := Pip{}
	// Create dynamic param values
	paramValues := map[string]types.Value{}
	paramValues["chdir"] = types.NewStringValue(&module.Params.Chdir)
	paramValues["editable"] = types.NewBoolValue(&module.Params.Editable)
	paramValues["executable"] = types.NewStringValue(&module.Params.Executable)
	paramValues["extra_args"] = types.NewStringValue(&module.Params.ExtraArgs)
	paramValues["name"] = types.NewStringListValue(&module.Params.Name)
	paramValues["requirements"] = types.NewStringValue(&module.Params.Requirements)
	paramValues["state"] = types.NewStringValue(&module.Params.State)
	paramValues["umask"] = types.NewStringValue(&module.Params.Umask)
	paramValues["version"] = types.NewStringValue(&module.Params.Version)
	paramValues["virtualenv"] = types.NewStringValue(&module.Params.Virtualenv)
	paramValues["virtualenv_command"] = types.NewStringValue(&module.Params.VirtualenvCommand)
	paramValues["virtualenv_python"] = types.NewStringValue(&module.Params.VirtualenvPython)
	paramValues["virtualenv_site_packages"] = types.NewBoolValue(&module.Params.VirtualenvSitePackages)
	module.Params.values = paramValues

	// Create dynamic result values
	resultValues := map[string]types.Value{}

	resultValues["cmd"] = types.NewStringValue(&module.Result.Cmd)
	resultValues["name"] = types.NewStringListValue(&module.Result.Name)
	resultValues["requirements"] = types.NewStringValue(&module.Result.Requirements)
	resultValues["version"] = types.NewStringValue(&module.Result.Version)
	resultValues["virtualenv"] = types.NewStringValue(&module.Result.Virtualenv)
	module.Result.values = resultValues

	return &module
}

// Pip (pip) - Manages Python library dependencies
//
// Manage Python library dependencies. To use this module, one of the following keys is required: C(name) or C(requirements).
//
//
// Source: https://github.com/ansible/ansible/blob/v2.13.1/lib/ansible/modules/pip.py
type Pip struct {
	Params PipParams
	Result PipResult
}

type PipParams struct {

	// Chdir
	// cd into this directory before running the command
	//
	// Default: <no value>
	// Required: false
	Chdir string `yaml:"chdir,omitempty" json:"chdir,omitempty" cty:"chdir"`

	// Editable
	// Pass the editable flag.
	//
	// Default: no
	// Required: false
	Editable bool `yaml:"editable,omitempty" json:"editable,omitempty" cty:"editable"`

	// Executable
	// The explicit executable or pathname for the pip executable, if different from the Ansible Python interpreter. For example C(pip3.3), if there are both Python 2.7 and 3.3 installations in the system and you want to run pip for the Python 3.3 installation.
	// Mutually exclusive with I(virtualenv) (added in 2.1).
	// Does not affect the Ansible Python interpreter.
	// The setuptools package must be installed for both the Ansible Python interpreter and for the version of Python specified by this option.
	//
	// Default: <no value>
	// Required: false
	Executable string `yaml:"executable,omitempty" json:"executable,omitempty" cty:"executable"`

	// ExtraArgs
	// Extra arguments passed to pip.
	//
	// Default: <no value>
	// Required: false
	ExtraArgs string `yaml:"extra_args,omitempty" json:"extra_args,omitempty" cty:"extra_args"`

	// Name
	// The name of a Python library to install or the url(bzr+,hg+,git+,svn+) of the remote package.
	// This can be a list (since 2.2) and contain version specifiers (since 2.7).
	//
	// Default: <no value>
	// Required: false
	Name []string `yaml:"name,omitempty" json:"name,omitempty" cty:"name"`

	// Requirements
	// The path to a pip requirements file, which should be local to the remote system. File can be specified as a relative path if using the chdir option.
	//
	// Default: <no value>
	// Required: false
	Requirements string `yaml:"requirements,omitempty" json:"requirements,omitempty" cty:"requirements"`

	// State
	// The state of module
	// The 'forcereinstall' option is only available in Ansible 2.1 and above.
	//
	// Default: present
	// Required: false
	State string `yaml:"state,omitempty" json:"state,omitempty" cty:"state"`

	// Umask
	// The system umask to apply before installing the pip package. This is useful, for example, when installing on systems that have a very restrictive umask by default (e.g., "0077") and you want to pip install packages which are to be used by all users. Note that this requires you to specify desired umask mode as an octal string, (e.g., "0022").
	//
	// Default: <no value>
	// Required: false
	Umask string `yaml:"umask,omitempty" json:"umask,omitempty" cty:"umask"`

	// Version
	// The version number to install of the Python library specified in the I(name) parameter.
	//
	// Default: <no value>
	// Required: false
	Version string `yaml:"version,omitempty" json:"version,omitempty" cty:"version"`

	// Virtualenv
	// An optional path to a I(virtualenv) directory to install into. It cannot be specified together with the 'executable' parameter (added in 2.1). If the virtualenv does not exist, it will be created before installing packages. The optional virtualenv_site_packages, virtualenv_command, and virtualenv_python options affect the creation of the virtualenv.
	//
	// Default: <no value>
	// Required: false
	Virtualenv string `yaml:"virtualenv,omitempty" json:"virtualenv,omitempty" cty:"virtualenv"`

	// VirtualenvCommand
	// The command or a pathname to the command to create the virtual environment with. For example C(pyvenv), C(virtualenv), C(virtualenv2), C(~/bin/virtualenv), C(/usr/local/bin/virtualenv).
	//
	// Default: virtualenv
	// Required: false
	VirtualenvCommand string `yaml:"virtualenv_command,omitempty" json:"virtualenv_command,omitempty" cty:"virtualenv_command"`

	// VirtualenvPython
	// The Python executable used for creating the virtual environment. For example C(python3.5), C(python2.7). When not specified, the Python version used to run the ansible module is used. This parameter should not be used when C(virtualenv_command) is using C(pyvenv) or the C(-m venv) module.
	//
	// Default: <no value>
	// Required: false
	VirtualenvPython string `yaml:"virtualenv_python,omitempty" json:"virtualenv_python,omitempty" cty:"virtualenv_python"`

	// VirtualenvSitePackages
	// Whether the virtual environment will inherit packages from the global site-packages directory.  Note that if this setting is changed on an already existing virtual environment it will not have any effect, the environment must be deleted and newly created.
	//
	// Default: no
	// Required: false
	VirtualenvSitePackages bool `yaml:"virtualenv_site_packages,omitempty" json:"virtualenv_site_packages,omitempty" cty:"virtualenv_site_packages"`

	values map[string]types.Value
}

func (p *PipParams) Names() []string {
	names := []string{}
	for name := range p.values {
		names = append(names, name)
	}
	return names
}

func (p *PipParams) Set(name string, value interface{}) error {
	v, ok := p.values[name]
	if !ok {
		return fmt.Errorf("no param with name %q", name)
	}
	return v.Set(value)
}

func (p *PipParams) Get(name string) (interface{}, error) {
	v, ok := p.values[name]
	if !ok {
		return nil, fmt.Errorf("no param with name %q", name)
	}
	return v.Get(), nil
}

type PipResult struct {
	types.CommonReturn
	Raw string

	// Cmd
	// pip command used by the module
	Cmd string `yaml:"cmd,omitempty" json:"cmd,omitempty" cty:"cmd"`

	// Name
	// list of python modules targetted by pip
	Name []string `yaml:"name,omitempty" json:"name,omitempty" cty:"name"`

	// Requirements
	// Path to the requirements file
	Requirements string `yaml:"requirements,omitempty" json:"requirements,omitempty" cty:"requirements"`

	// Version
	// Version of the package specified in 'name'
	Version string `yaml:"version,omitempty" json:"version,omitempty" cty:"version"`

	// Virtualenv
	// Path to the virtualenv
	Virtualenv string `yaml:"virtualenv,omitempty" json:"virtualenv,omitempty" cty:"virtualenv"`

	values map[string]types.Value
}

func (r *PipResult) Names() []string {
	names := []string{}
	for name := range r.values {
		names = append(names, name)
	}
	return names
}

func (r *PipResult) Set(name string, value interface{}) error {
	v, ok := r.values[name]
	if !ok {
		return fmt.Errorf("no param with name %q", name)
	}
	return v.Set(value)
}

func (r *PipResult) Get(name string) (interface{}, error) {
	v, ok := r.values[name]
	if !ok {
		return nil, fmt.Errorf("no param with name %q", name)
	}
	return v.Get(), nil
}

func (m *Pip) GetResult() types.Result {
	return &m.Result
}

func (m *Pip) GetResultRaw() string {
	return m.Result.Raw
}

func (m *Pip) GetCommonResult() types.CommonReturn {
	return m.Result.CommonReturn
}

func (m *Pip) GetParams() types.Params {
	return &m.Params
}

func (m *Pip) GetType() string {
	return "pip"
}
