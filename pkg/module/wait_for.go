package module

// Autogenerated file

import (
	"fmt"
	"github.com/weakpixel/aig/pkg/types"
)

func init() {
	addModuleFactory("wait_for", func() types.Module {
		return NewWaitFor()
	})
}

//
// WaitFor (wait_for) - Waits for a condition before continuing
//
func NewWaitFor() *WaitFor {
	module := WaitFor{}
	// Create dynamic param values
	paramValues := map[string]types.Value{}
	paramValues["active_connection_states"] = types.NewStringArrayValue(&module.Params.ActiveConnectionStates)
	paramValues["connect_timeout"] = types.NewIntValue(&module.Params.ConnectTimeout)
	paramValues["delay"] = types.NewIntValue(&module.Params.Delay)
	paramValues["exclude_hosts"] = types.NewStringArrayValue(&module.Params.ExcludeHosts)
	paramValues["host"] = types.NewStringValue(&module.Params.Host)
	paramValues["msg"] = types.NewStringValue(&module.Params.Msg)
	paramValues["path"] = types.NewStringValue(&module.Params.Path)
	paramValues["port"] = types.NewIntValue(&module.Params.Port)
	paramValues["search_regex"] = types.NewStringValue(&module.Params.SearchRegex)
	paramValues["sleep"] = types.NewIntValue(&module.Params.Sleep)
	paramValues["state"] = types.NewStringValue(&module.Params.State)
	paramValues["timeout"] = types.NewIntValue(&module.Params.Timeout)
	module.Params.values = paramValues

	// Create dynamic result values
	resultValues := map[string]types.Value{}

	resultValues["elapsed"] = types.NewIntValue(&module.Result.Elapsed)
	resultValues["match_groupdict"] = types.NewStringMapValue(&module.Result.MatchGroupdict)
	// NOT SUPPORTED: match_groups MatchGroups []map[string]interface{}
	module.Result.values = resultValues

	return &module
}

// WaitFor (wait_for) - Waits for a condition before continuing
//
// You can wait for a set amount of time C(timeout), this is the default if nothing is specified or just C(timeout) is specified. This does not produce an error.
//
// Waiting for a port to become available is useful for when services are not immediately available after their init scripts return which is true of certain Java application servers.
//
// It is also useful when starting guests with the M(community.libvirt.virt) module and needing to pause until they are ready.
//
// This module can also be used to wait for a regex match a string to be present in a file.
//
// In Ansible 1.6 and later, this module can also be used to wait for a file to be available or absent on the filesystem.
//
// In Ansible 1.8 and later, this module can also be used to wait for active connections to be closed before continuing, useful if a node is being rotated out of a load balancer pool.
//
// For Windows targets, use the M(ansible.windows.win_wait_for) module instead.
//
//
// Source: https://github.com/ansible/ansible/blob/v2.13.1/lib/ansible/modules/wait_for.py
type WaitFor struct {
	Params WaitForParams
	Result WaitForResult
}

type WaitForParams struct {

	// ActiveConnectionStates
	// The list of TCP connection states which are counted as active connections.
	//
	// Default: [ESTABLISHED FIN_WAIT1 FIN_WAIT2 SYN_RECV SYN_SENT TIME_WAIT]
	// Required: false
	ActiveConnectionStates []string `yaml:"active_connection_states,omitempty" json:"active_connection_states,omitempty"`

	// ConnectTimeout
	// Maximum number of seconds to wait for a connection to happen before closing and retrying.
	//
	// Default: 5
	// Required: false
	ConnectTimeout int `yaml:"connect_timeout,omitempty" json:"connect_timeout,omitempty"`

	// Delay
	// Number of seconds to wait before starting to poll.
	//
	// Default: 0
	// Required: false
	Delay int `yaml:"delay,omitempty" json:"delay,omitempty"`

	// ExcludeHosts
	// List of hosts or IPs to ignore when looking for active TCP connections for C(drained) state.
	//
	// Default: <no value>
	// Required: false
	ExcludeHosts []string `yaml:"exclude_hosts,omitempty" json:"exclude_hosts,omitempty"`

	// Host
	// A resolvable hostname or IP address to wait for.
	//
	// Default: 127.0.0.1
	// Required: false
	Host string `yaml:"host,omitempty" json:"host,omitempty"`

	// Msg
	// This overrides the normal error message from a failure to meet the required conditions.
	//
	// Default: <no value>
	// Required: false
	Msg string `yaml:"msg,omitempty" json:"msg,omitempty"`

	// Path
	// Path to a file on the filesystem that must exist before continuing.
	// C(path) and C(port) are mutually exclusive parameters.
	//
	// Default: <no value>
	// Required: false
	Path string `yaml:"path,omitempty" json:"path,omitempty"`

	// Port
	// Port number to poll.
	// C(path) and C(port) are mutually exclusive parameters.
	//
	// Default: <no value>
	// Required: false
	Port int `yaml:"port,omitempty" json:"port,omitempty"`

	// SearchRegex
	// Can be used to match a string in either a file or a socket connection.
	// Defaults to a multiline regex.
	//
	// Default: <no value>
	// Required: false
	SearchRegex string `yaml:"search_regex,omitempty" json:"search_regex,omitempty"`

	// Sleep
	// Number of seconds to sleep between checks.
	// Before Ansible 2.3 this was hardcoded to 1 second.
	//
	// Default: 1
	// Required: false
	Sleep int `yaml:"sleep,omitempty" json:"sleep,omitempty"`

	// State
	// Either C(present), C(started), or C(stopped), C(absent), or C(drained).
	// When checking a port C(started) will ensure the port is open, C(stopped) will check that it is closed, C(drained) will check for active connections.
	// When checking for a file or a search string C(present) or C(started) will ensure that the file or string is present before continuing, C(absent) will check that file is absent or removed.
	//
	// Default: started
	// Required: false
	State string `yaml:"state,omitempty" json:"state,omitempty"`

	// Timeout
	// Maximum number of seconds to wait for, when used with another condition it will force an error.
	// When used without other conditions it is equivalent of just sleeping.
	//
	// Default: 300
	// Required: false
	Timeout int `yaml:"timeout,omitempty" json:"timeout,omitempty"`

	values map[string]types.Value
}

func (p *WaitForParams) Names() []string {
	names := []string{}
	for name := range p.values {
		names = append(names, name)
	}
	return names
}

func (p *WaitForParams) Set(name string, value interface{}) error {
	v, ok := p.values[name]
	if !ok {
		return fmt.Errorf("no param with name %q", name)
	}
	return v.Set(value)
}

func (p *WaitForParams) Get(name string) (interface{}, error) {
	v, ok := p.values[name]
	if !ok {
		return nil, fmt.Errorf("no param with name %q", name)
	}
	return v.Get(), nil
}

type WaitForResult struct {
	types.CommonReturn
	Raw string

	// Elapsed
	// The number of seconds that elapsed while waiting
	Elapsed int `yaml:"elapsed,omitempty" json:"elapsed,omitempty"`

	// MatchGroupdict
	// Dictionary containing all the named subgroups of the match, keyed by the subgroup name, as returned by U(https://docs.python.org/3/library/re.html#re.MatchObject.groupdict)
	MatchGroupdict map[string]string `yaml:"match_groupdict,omitempty" json:"match_groupdict,omitempty"`

	// MatchGroups
	// Tuple containing all the subgroups of the match as returned by U(https://docs.python.org/3/library/re.html#re.MatchObject.groups)
	MatchGroups []map[string]interface{} `yaml:"match_groups,omitempty" json:"match_groups,omitempty"`

	values map[string]types.Value
}

func (r *WaitForResult) Names() []string {
	names := []string{}
	for name := range r.values {
		names = append(names, name)
	}
	return names
}

func (r *WaitForResult) Set(name string, value interface{}) error {
	v, ok := r.values[name]
	if !ok {
		return fmt.Errorf("no param with name %q", name)
	}
	return v.Set(value)
}

func (r *WaitForResult) Get(name string) (interface{}, error) {
	v, ok := r.values[name]
	if !ok {
		return nil, fmt.Errorf("no param with name %q", name)
	}
	return v.Get(), nil
}

func (m *WaitFor) GetResult() types.Result {
	return &m.Result
}

func (m *WaitFor) GetResultRaw() string {
	return m.Result.Raw
}

func (m *WaitFor) GetCommonResult() types.CommonReturn {
	return m.Result.CommonReturn
}

func (m *WaitFor) GetParams() types.Params {
	return &m.Params
}

func (m *WaitFor) GetType() string {
	return "wait_for"
}
