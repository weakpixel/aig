package module

// Autogenerated file

import (
	"fmt"
	"github.com/weakpixel/aig/pkg/types"
)

func init() {
	addModuleFactory("setup", func() types.Module {
		return NewSetup()
	})
}

//
// Setup (setup) - Gathers facts about remote hosts
//
func NewSetup() *Setup {
	module := Setup{}
	// Create dynamic param values
	paramValues := map[string]types.Value{}
	paramValues["fact_path"] = types.NewStringValue(&module.Params.FactPath)
	paramValues["filter"] = types.NewStringArrayValue(&module.Params.Filter)
	paramValues["gather_subset"] = types.NewStringArrayValue(&module.Params.GatherSubset)
	paramValues["gather_timeout"] = types.NewIntValue(&module.Params.GatherTimeout)
	module.Params.values = paramValues

	// Create dynamic result values
	resultValues := map[string]types.Value{}

	module.Result.values = resultValues

	return &module
}

// Setup (setup) - Gathers facts about remote hosts
//
// This module is automatically called by playbooks to gather useful variables about remote hosts that can be used in playbooks. It can also be executed directly by C(/usr/bin/ansible) to check what variables are available to a host. Ansible provides many I(facts) about the system, automatically.
//
// This module is also supported for Windows targets.
//
//
// Source: https://github.com/ansible/ansible/blob/v2.13.1/lib/ansible/modules/setup.py
type Setup struct {
	Params SetupParams
	Result SetupResult
}

type SetupParams struct {

	// FactPath
	// Path used for local ansible facts (C(*.fact)) - files in this dir will be run (if executable) and their results be added to C(ansible_local) facts. If a file is not executable it is read instead. File/results format can be JSON or INI-format. The default C(fact_path) can be specified in C(ansible.cfg) for when setup is automatically called as part of C(gather_facts). NOTE - For windows clients, the results will be added to a variable named after the local file (without extension suffix), rather than C(ansible_local).
	// Since Ansible 2.1, Windows hosts can use C(fact_path). Make sure that this path exists on the target host. Files in this path MUST be PowerShell scripts C(.ps1) which outputs an object. This object will be formatted by Ansible as json so the script should be outputting a raw hashtable, array, or other primitive object.
	//
	// Default: /etc/ansible/facts.d
	// Required: false
	FactPath string `yaml:"fact_path,omitempty" json:"fact_path,omitempty"`

	// Filter
	// If supplied, only return facts that match one of the shell-style (fnmatch) pattern. An empty list basically means 'no filter'. As of Ansible 2.11, the type has changed from string to list and the default has became an empty list. A simple string is still accepted and works as a single pattern. The behaviour prior to Ansible 2.11 remains.
	//
	// Default: []
	// Required: false
	Filter []string `yaml:"filter,omitempty" json:"filter,omitempty"`

	// GatherSubset
	// If supplied, restrict the additional facts collected to the given subset. Possible values: C(all), C(min), C(hardware), C(network), C(virtual), C(ohai), and C(facter). Can specify a list of values to specify a larger subset. Values can also be used with an initial C(!) to specify that that specific subset should not be collected.  For instance: C(!hardware,!network,!virtual,!ohai,!facter). If C(!all) is specified then only the min subset is collected. To avoid collecting even the min subset, specify C(!all,!min). To collect only specific facts, use C(!all,!min), and specify the particular fact subsets. Use the filter parameter if you do not want to display some collected facts.
	//
	// Default: all
	// Required: false
	GatherSubset []string `yaml:"gather_subset,omitempty" json:"gather_subset,omitempty"`

	// GatherTimeout
	// Set the default timeout in seconds for individual fact gathering.
	//
	// Default: 10
	// Required: false
	GatherTimeout int `yaml:"gather_timeout,omitempty" json:"gather_timeout,omitempty"`

	values map[string]types.Value
}

func (p *SetupParams) Names() []string {
	names := []string{}
	for name := range p.values {
		names = append(names, name)
	}
	return []string{}
}

func (p *SetupParams) Set(name string, value interface{}) error {
	v, ok := p.values[name]
	if !ok {
		return fmt.Errorf("no param with name %q", name)
	}
	return v.Set(value)
}

func (p *SetupParams) Get(name string) (interface{}, error) {
	v, ok := p.values[name]
	if !ok {
		return nil, fmt.Errorf("no param with name %q", name)
	}
	return v.Get(), nil
}

type SetupResult struct {
	types.CommonReturn
	Raw string

	values map[string]types.Value
}

func (r *SetupResult) Names() []string {
	names := []string{}
	for name := range r.values {
		names = append(names, name)
	}
	return []string{}
}

func (r *SetupResult) Set(name string, value interface{}) error {
	v, ok := r.values[name]
	if !ok {
		return fmt.Errorf("no param with name %q", name)
	}
	return v.Set(value)
}

func (r *SetupResult) Get(name string) (interface{}, error) {
	v, ok := r.values[name]
	if !ok {
		return nil, fmt.Errorf("no param with name %q", name)
	}
	return v.Get(), nil
}

func (m *Setup) GetResult() types.Result {
	return &m.Result
}

func (m *Setup) GetResultRaw() string {
	return m.Result.Raw
}

func (m *Setup) GetCommonResult() types.CommonReturn {
	return m.Result.CommonReturn
}

func (m *Setup) GetParams() types.Params {
	return &m.Params
}

func (m *Setup) GetType() string {
	return "setup"
}
