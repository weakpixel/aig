package module

// Autogenerated file

import (
	"fmt"
	"github.com/weakpixel/aig/pkg/types"
)

func init() {
	addModuleFactory("file", func() types.Module {
		return NewFile()
	})
}

//
// File (file) - Manage files and file properties
//
func NewFile() *File {
	module := File{}
	// Create dynamic param values
	paramValues := map[string]types.Value{}
	paramValues["access_time"] = types.NewStringValue(&module.Params.AccessTime)
	paramValues["access_time_format"] = types.NewStringValue(&module.Params.AccessTimeFormat)
	paramValues["follow"] = types.NewBoolValue(&module.Params.Follow)
	paramValues["force"] = types.NewBoolValue(&module.Params.Force)
	paramValues["modification_time"] = types.NewStringValue(&module.Params.ModificationTime)
	paramValues["modification_time_format"] = types.NewStringValue(&module.Params.ModificationTimeFormat)
	paramValues["path"] = types.NewStringValue(&module.Params.Path)
	paramValues["recurse"] = types.NewBoolValue(&module.Params.Recurse)
	paramValues["src"] = types.NewStringValue(&module.Params.Src)
	paramValues["state"] = types.NewStringValue(&module.Params.State)
	module.Params.values = paramValues

	// Create dynamic result values
	resultValues := map[string]types.Value{}

	resultValues["dest"] = types.NewStringValue(&module.Result.Dest)
	resultValues["path"] = types.NewStringValue(&module.Result.Path)
	module.Result.values = resultValues

	return &module
}

// File (file) - Manage files and file properties
//
// Set attributes of files, symlinks or directories.
//
// Alternatively, remove files, symlinks or directories.
//
// Many other modules support the same options as the C(file) module - including M(ansible.builtin.copy), M(ansible.builtin.template), and M(ansible.builtin.assemble).
//
// For Windows targets, use the M(ansible.windows.win_file) module instead.
//
//
// Source: https://github.com/ansible/ansible/blob/v2.13.1/lib/ansible/modules/file.py
type File struct {
	Params FileParams
	Result FileResult
}

type FileParams struct {

	// AccessTime
	// This parameter indicates the time the file's access time should be set to.
	// Should be C(preserve) when no modification is required, C(YYYYMMDDHHMM.SS) when using default time format, or C(now).
	// Default is C(None) meaning that C(preserve) is the default for C(state=[file,directory,link,hard]) and C(now) is default for C(state=touch).
	//
	// Default: <no value>
	// Required: false
	AccessTime string `yaml:"access_time,omitempty" json:"access_time,omitempty" cty:"access_time"`

	// AccessTimeFormat
	// When used with C(access_time), indicates the time format that must be used.
	// Based on default Python format (see time.strftime doc).
	//
	// Default: %Y%m%d%H%M.%S
	// Required: false
	AccessTimeFormat string `yaml:"access_time_format,omitempty" json:"access_time_format,omitempty" cty:"access_time_format"`

	// Follow
	// This flag indicates that filesystem links, if they exist, should be followed.
	// Previous to Ansible 2.5, this was C(no) by default.
	//
	// Default: yes
	// Required: false
	Follow bool `yaml:"follow,omitempty" json:"follow,omitempty" cty:"follow"`

	// Force
	// Force the creation of the symlinks in two cases: the source file does not exist (but will appear later); the destination exists and is a file (so, we need to unlink the C(path) file and create symlink to the C(src) file in place of it).

	//
	// Default: no
	// Required: false
	Force bool `yaml:"force,omitempty" json:"force,omitempty" cty:"force"`

	// ModificationTime
	// This parameter indicates the time the file's modification time should be set to.
	// Should be C(preserve) when no modification is required, C(YYYYMMDDHHMM.SS) when using default time format, or C(now).
	// Default is None meaning that C(preserve) is the default for C(state=[file,directory,link,hard]) and C(now) is default for C(state=touch).
	//
	// Default: <no value>
	// Required: false
	ModificationTime string `yaml:"modification_time,omitempty" json:"modification_time,omitempty" cty:"modification_time"`

	// ModificationTimeFormat
	// When used with C(modification_time), indicates the time format that must be used.
	// Based on default Python format (see time.strftime doc).
	//
	// Default: %Y%m%d%H%M.%S
	// Required: false
	ModificationTimeFormat string `yaml:"modification_time_format,omitempty" json:"modification_time_format,omitempty" cty:"modification_time_format"`

	// Path
	// Path to the file being managed.
	//
	// Default: <no value>
	// Required: true
	Path string `yaml:"path,omitempty" json:"path,omitempty" cty:"path"`

	// Recurse
	// Recursively set the specified file attributes on directory contents.
	// This applies only when C(state) is set to C(directory).
	//
	// Default: no
	// Required: false
	Recurse bool `yaml:"recurse,omitempty" json:"recurse,omitempty" cty:"recurse"`

	// Src
	// Path of the file to link to.
	// This applies only to C(state=link) and C(state=hard).
	// For C(state=link), this will also accept a non-existing path.
	// Relative paths are relative to the file being created (C(path)) which is how the Unix command C(ln -s SRC DEST) treats relative paths.
	//
	// Default: <no value>
	// Required: false
	Src string `yaml:"src,omitempty" json:"src,omitempty" cty:"src"`

	// State
	// If C(absent), directories will be recursively deleted, and files or symlinks will be unlinked. In the case of a directory, if C(diff) is declared, you will see the files and folders deleted listed under C(path_contents). Note that C(absent) will not cause C(file) to fail if the C(path) does not exist as the state did not change.
	// If C(directory), all intermediate subdirectories will be created if they do not exist. Since Ansible 1.7 they will be created with the supplied permissions.
	// If C(file), with no other options, returns the current state of C(path).
	// If C(file), even with other options (such as C(mode)), the file will be modified if it exists but will NOT be created if it does not exist. Set to C(touch) or use the M(ansible.builtin.copy) or M(ansible.builtin.template) module if you want to create the file if it does not exist.
	// If C(hard), the hard link will be created or changed.
	// If C(link), the symbolic link will be created or changed.
	// If C(touch) (new in 1.4), an empty file will be created if the file does not exist, while an existing file or directory will receive updated file access and modification times (similar to the way C(touch) works from the command line).
	//
	// Default: file
	// Required: false
	State string `yaml:"state,omitempty" json:"state,omitempty" cty:"state"`

	values map[string]types.Value
}

func (p *FileParams) Names() []string {
	names := []string{}
	for name := range p.values {
		names = append(names, name)
	}
	return names
}

func (p *FileParams) Set(name string, value interface{}) error {
	v, ok := p.values[name]
	if !ok {
		return fmt.Errorf("no param with name %q", name)
	}
	return v.Set(value)
}

func (p *FileParams) Get(name string) (interface{}, error) {
	v, ok := p.values[name]
	if !ok {
		return nil, fmt.Errorf("no param with name %q", name)
	}
	return v.Get(), nil
}

type FileResult struct {
	types.CommonReturn
	Raw string

	// Dest
	// Destination file/path, equal to the value passed to I(path).
	Dest string `yaml:"dest,omitempty" json:"dest,omitempty" cty:"dest"`

	// Path
	// Destination file/path, equal to the value passed to I(path).
	Path string `yaml:"path,omitempty" json:"path,omitempty" cty:"path"`

	values map[string]types.Value
}

func (r *FileResult) Names() []string {
	names := []string{}
	for name := range r.values {
		names = append(names, name)
	}
	return names
}

func (r *FileResult) Set(name string, value interface{}) error {
	v, ok := r.values[name]
	if !ok {
		return fmt.Errorf("no param with name %q", name)
	}
	return v.Set(value)
}

func (r *FileResult) Get(name string) (interface{}, error) {
	v, ok := r.values[name]
	if !ok {
		return nil, fmt.Errorf("no param with name %q", name)
	}
	return v.Get(), nil
}

func (m *File) GetResult() types.Result {
	return &m.Result
}

func (m *File) GetResultRaw() string {
	return m.Result.Raw
}

func (m *File) GetCommonResult() types.CommonReturn {
	return m.Result.CommonReturn
}

func (m *File) GetParams() types.Params {
	return &m.Params
}

func (m *File) GetType() string {
	return "file"
}
