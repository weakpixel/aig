package module

// Autogenerated file

import (
	"fmt"
	"github.com/weakpixel/aig/pkg/types"
)

func init() {
	addModuleFactory("hostname", func() types.Module {
		return NewHostname()
	})
}

//
// Hostname (hostname) - Manage hostname
//
func NewHostname() *Hostname {
	module := Hostname{}
	// Create dynamic param values
	paramValues := map[string]types.Value{}
	paramValues["name"] = types.NewStringValue(&module.Params.Name)
	paramValues["use"] = types.NewStringValue(&module.Params.Use)
	module.Params.values = paramValues

	// Create dynamic result values
	resultValues := map[string]types.Value{}

	module.Result.values = resultValues

	return &module
}

// Hostname (hostname) - Manage hostname
//
// Set system's hostname. Supports most OSs/Distributions including those using C(systemd).
//
// Windows, HP-UX, and AIX are not currently supported.
//
//
// Source: https://github.com/ansible/ansible/blob/v2.13.1/lib/ansible/modules/hostname.py
type Hostname struct {
	Params HostnameParams
	Result HostnameResult
}

type HostnameParams struct {

	// Name
	// Name of the host.
	// If the value is a fully qualified domain name that does not resolve from the given host, this will cause the module to hang for a few seconds while waiting for the name resolution attempt to timeout.
	//
	// Default: <no value>
	// Required: true
	Name string `yaml:"name,omitempty" json:"name,omitempty"`

	// Use
	// Which strategy to use to update the hostname.
	// If not set we try to autodetect, but this can be problematic, particularly with containers as they can present misleading information.
	// Note that 'systemd' should be specified for RHEL/EL/CentOS 7+. Older distributions should use 'redhat'.
	//
	// Default: <no value>
	// Required: false
	Use string `yaml:"use,omitempty" json:"use,omitempty"`

	values map[string]types.Value
}

func (p *HostnameParams) Names() []string {
	names := []string{}
	for name := range p.values {
		names = append(names, name)
	}
	return names
}

func (p *HostnameParams) Set(name string, value interface{}) error {
	v, ok := p.values[name]
	if !ok {
		return fmt.Errorf("no param with name %q", name)
	}
	return v.Set(value)
}

func (p *HostnameParams) Get(name string) (interface{}, error) {
	v, ok := p.values[name]
	if !ok {
		return nil, fmt.Errorf("no param with name %q", name)
	}
	return v.Get(), nil
}

type HostnameResult struct {
	types.CommonReturn
	Raw string

	values map[string]types.Value
}

func (r *HostnameResult) Names() []string {
	names := []string{}
	for name := range r.values {
		names = append(names, name)
	}
	return names
}

func (r *HostnameResult) Set(name string, value interface{}) error {
	v, ok := r.values[name]
	if !ok {
		return fmt.Errorf("no param with name %q", name)
	}
	return v.Set(value)
}

func (r *HostnameResult) Get(name string) (interface{}, error) {
	v, ok := r.values[name]
	if !ok {
		return nil, fmt.Errorf("no param with name %q", name)
	}
	return v.Get(), nil
}

func (m *Hostname) GetResult() types.Result {
	return &m.Result
}

func (m *Hostname) GetResultRaw() string {
	return m.Result.Raw
}

func (m *Hostname) GetCommonResult() types.CommonReturn {
	return m.Result.CommonReturn
}

func (m *Hostname) GetParams() types.Params {
	return &m.Params
}

func (m *Hostname) GetType() string {
	return "hostname"
}
