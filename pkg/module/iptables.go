package module

// Autogenerated file

import (
	"fmt"
	"github.com/weakpixel/aig/pkg/types"
)

func init() {
	addModuleFactory("iptables", func() types.Module {
		return NewIptables()
	})
}

//
// Iptables (iptables) - Modify iptables rules
//
func NewIptables() *Iptables {
	module := Iptables{}
	// Create dynamic param values
	paramValues := map[string]types.Value{}
	paramValues["action"] = types.NewStringValue(&module.Params.Action)
	paramValues["chain"] = types.NewStringValue(&module.Params.Chain)
	paramValues["chain_management"] = types.NewBoolValue(&module.Params.ChainManagement)
	paramValues["comment"] = types.NewStringValue(&module.Params.Comment)
	paramValues["ctstate"] = types.NewStringArrayValue(&module.Params.Ctstate)
	paramValues["destination"] = types.NewStringValue(&module.Params.Destination)
	paramValues["destination_port"] = types.NewStringValue(&module.Params.DestinationPort)
	paramValues["destination_ports"] = types.NewStringArrayValue(&module.Params.DestinationPorts)
	paramValues["dst_range"] = types.NewStringValue(&module.Params.DstRange)
	paramValues["flush"] = types.NewBoolValue(&module.Params.Flush)
	paramValues["fragment"] = types.NewStringValue(&module.Params.Fragment)
	paramValues["gateway"] = types.NewStringValue(&module.Params.Gateway)
	paramValues["gid_owner"] = types.NewStringValue(&module.Params.GidOwner)
	paramValues["goto"] = types.NewStringValue(&module.Params.Goto)
	paramValues["icmp_type"] = types.NewStringValue(&module.Params.IcmpType)
	paramValues["in_interface"] = types.NewStringValue(&module.Params.InInterface)
	paramValues["ip_version"] = types.NewStringValue(&module.Params.IpVersion)
	paramValues["jump"] = types.NewStringValue(&module.Params.Jump)
	paramValues["limit"] = types.NewStringValue(&module.Params.Limit)
	paramValues["limit_burst"] = types.NewStringValue(&module.Params.LimitBurst)
	paramValues["log_level"] = types.NewStringValue(&module.Params.LogLevel)
	paramValues["log_prefix"] = types.NewStringValue(&module.Params.LogPrefix)
	paramValues["match"] = types.NewStringArrayValue(&module.Params.Match)
	paramValues["match_set"] = types.NewStringValue(&module.Params.MatchSet)
	paramValues["match_set_flags"] = types.NewStringValue(&module.Params.MatchSetFlags)
	paramValues["out_interface"] = types.NewStringValue(&module.Params.OutInterface)
	paramValues["policy"] = types.NewStringValue(&module.Params.Policy)
	paramValues["protocol"] = types.NewStringValue(&module.Params.Protocol)
	paramValues["reject_with"] = types.NewStringValue(&module.Params.RejectWith)
	paramValues["rule_num"] = types.NewStringValue(&module.Params.RuleNum)
	paramValues["set_counters"] = types.NewStringValue(&module.Params.SetCounters)
	paramValues["set_dscp_mark"] = types.NewStringValue(&module.Params.SetDscpMark)
	paramValues["set_dscp_mark_class"] = types.NewStringValue(&module.Params.SetDscpMarkClass)
	paramValues["source"] = types.NewStringValue(&module.Params.Source)
	paramValues["source_port"] = types.NewStringValue(&module.Params.SourcePort)
	paramValues["src_range"] = types.NewStringValue(&module.Params.SrcRange)
	paramValues["state"] = types.NewStringValue(&module.Params.State)
	paramValues["syn"] = types.NewStringValue(&module.Params.Syn)
	paramValues["table"] = types.NewStringValue(&module.Params.Table)
	paramValues["tcp_flags"] = types.NewStringMapValue(&module.Params.TcpFlags)
	paramValues["to_destination"] = types.NewStringValue(&module.Params.ToDestination)
	paramValues["to_ports"] = types.NewStringValue(&module.Params.ToPorts)
	paramValues["to_source"] = types.NewStringValue(&module.Params.ToSource)
	paramValues["uid_owner"] = types.NewStringValue(&module.Params.UidOwner)
	paramValues["wait"] = types.NewStringValue(&module.Params.Wait)
	module.Params.values = paramValues

	// Create dynamic result values
	resultValues := map[string]types.Value{}

	module.Result.values = resultValues

	return &module
}

// Iptables (iptables) - Modify iptables rules
//
// C(iptables) is used to set up, maintain, and inspect the tables of IP packet filter rules in the Linux kernel.
//
// This module does not handle the saving and/or loading of rules, but rather only manipulates the current rules that are present in memory. This is the same as the behaviour of the C(iptables) and C(ip6tables) command which this module uses internally.
//
//
// Source: https://github.com/ansible/ansible/blob/v2.13.1/lib/ansible/modules/iptables.py
type Iptables struct {
	Params IptablesParams
	Result IptablesResult
}

type IptablesParams struct {

	// Action
	// Whether the rule should be appended at the bottom or inserted at the top.
	// If the rule already exists the chain will not be modified.
	//
	// Default: append
	// Required: false
	Action string `yaml:"action,omitempty" json:"action,omitempty"`

	// Chain
	// Specify the iptables chain to modify.
	// This could be a user-defined chain or one of the standard iptables chains, like C(INPUT), C(FORWARD), C(OUTPUT), C(PREROUTING), C(POSTROUTING), C(SECMARK) or C(CONNSECMARK).
	//
	// Default: <no value>
	// Required: false
	Chain string `yaml:"chain,omitempty" json:"chain,omitempty"`

	// ChainManagement
	// If C(true) and C(state) is C(present), the chain will be created if needed.
	// If C(true) and C(state) is C(absent), the chain will be deleted if the only other parameter passed are C(chain) and optionally C(table).
	//
	// Default: false
	// Required: false
	ChainManagement bool `yaml:"chain_management,omitempty" json:"chain_management,omitempty"`

	// Comment
	// This specifies a comment that will be added to the rule.
	//
	// Default: <no value>
	// Required: false
	Comment string `yaml:"comment,omitempty" json:"comment,omitempty"`

	// Ctstate
	// A list of the connection states to match in the conntrack module.
	// Possible values are C(INVALID), C(NEW), C(ESTABLISHED), C(RELATED), C(UNTRACKED), C(SNAT), C(DNAT).
	//
	// Default: []
	// Required: false
	Ctstate []string `yaml:"ctstate,omitempty" json:"ctstate,omitempty"`

	// Destination
	// Destination specification.
	// Address can be either a network name, a hostname, a network IP address (with /mask), or a plain IP address.
	// Hostnames will be resolved once only, before the rule is submitted to the kernel. Please note that specifying any name to be resolved with a remote query such as DNS is a really bad idea.
	// The mask can be either a network mask or a plain number, specifying the number of 1's at the left side of the network mask. Thus, a mask of 24 is equivalent to 255.255.255.0. A C(!) argument before the address specification inverts the sense of the address.
	//
	// Default: <no value>
	// Required: false
	Destination string `yaml:"destination,omitempty" json:"destination,omitempty"`

	// DestinationPort
	// Destination port or port range specification. This can either be a service name or a port number. An inclusive range can also be specified, using the format first:last. If the first port is omitted, '0' is assumed; if the last is omitted, '65535' is assumed. If the first port is greater than the second one they will be swapped. This is only valid if the rule also specifies one of the following protocols: tcp, udp, dccp or sctp.
	//
	// Default: <no value>
	// Required: false
	DestinationPort string `yaml:"destination_port,omitempty" json:"destination_port,omitempty"`

	// DestinationPorts
	// This specifies multiple destination port numbers or port ranges to match in the multiport module.
	// It can only be used in conjunction with the protocols tcp, udp, udplite, dccp and sctp.
	//
	// Default: <no value>
	// Required: false
	DestinationPorts []string `yaml:"destination_ports,omitempty" json:"destination_ports,omitempty"`

	// DstRange
	// Specifies the destination IP range to match in the iprange module.
	//
	// Default: <no value>
	// Required: false
	DstRange string `yaml:"dst_range,omitempty" json:"dst_range,omitempty"`

	// Flush
	// Flushes the specified table and chain of all rules.
	// If no chain is specified then the entire table is purged.
	// Ignores all other parameters.
	//
	// Default: false
	// Required: false
	Flush bool `yaml:"flush,omitempty" json:"flush,omitempty"`

	// Fragment
	// This means that the rule only refers to second and further fragments of fragmented packets.
	// Since there is no way to tell the source or destination ports of such a packet (or ICMP type), such a packet will not match any rules which specify them.
	// When the "!" argument precedes fragment argument, the rule will only match head fragments, or unfragmented packets.
	//
	// Default: <no value>
	// Required: false
	Fragment string `yaml:"fragment,omitempty" json:"fragment,omitempty"`

	// Gateway
	// This specifies the IP address of host to send the cloned packets.
	// This option is only valid when C(jump) is set to C(TEE).
	//
	// Default: <no value>
	// Required: false
	Gateway string `yaml:"gateway,omitempty" json:"gateway,omitempty"`

	// GidOwner
	// Specifies the GID or group to use in match by owner rule.
	//
	// Default: <no value>
	// Required: false
	GidOwner string `yaml:"gid_owner,omitempty" json:"gid_owner,omitempty"`

	// Goto
	// This specifies that the processing should continue in a user specified chain.
	// Unlike the jump argument return will not continue processing in this chain but instead in the chain that called us via jump.
	//
	// Default: <no value>
	// Required: false
	Goto string `yaml:"goto,omitempty" json:"goto,omitempty"`

	// IcmpType
	// This allows specification of the ICMP type, which can be a numeric ICMP type, type/code pair, or one of the ICMP type names shown by the command 'iptables -p icmp -h'
	//
	// Default: <no value>
	// Required: false
	IcmpType string `yaml:"icmp_type,omitempty" json:"icmp_type,omitempty"`

	// InInterface
	// Name of an interface via which a packet was received (only for packets entering the C(INPUT), C(FORWARD) and C(PREROUTING) chains).
	// When the C(!) argument is used before the interface name, the sense is inverted.
	// If the interface name ends in a C(+), then any interface which begins with this name will match.
	// If this option is omitted, any interface name will match.
	//
	// Default: <no value>
	// Required: false
	InInterface string `yaml:"in_interface,omitempty" json:"in_interface,omitempty"`

	// IpVersion
	// Which version of the IP protocol this rule should apply to.
	//
	// Default: ipv4
	// Required: false
	IpVersion string `yaml:"ip_version,omitempty" json:"ip_version,omitempty"`

	// Jump
	// This specifies the target of the rule; i.e., what to do if the packet matches it.
	// The target can be a user-defined chain (other than the one this rule is in), one of the special builtin targets which decide the fate of the packet immediately, or an extension (see EXTENSIONS below).
	// If this option is omitted in a rule (and the goto parameter is not used), then matching the rule will have no effect on the packet's fate, but the counters on the rule will be incremented.
	//
	// Default: <no value>
	// Required: false
	Jump string `yaml:"jump,omitempty" json:"jump,omitempty"`

	// Limit
	// Specifies the maximum average number of matches to allow per second.
	// The number can specify units explicitly, using C(/second), C(/minute), C(/hour) or C(/day), or parts of them (so C(5/second) is the same as C(5/s)).
	//
	// Default: <no value>
	// Required: false
	Limit string `yaml:"limit,omitempty" json:"limit,omitempty"`

	// LimitBurst
	// Specifies the maximum burst before the above limit kicks in.
	//
	// Default: <no value>
	// Required: false
	LimitBurst string `yaml:"limit_burst,omitempty" json:"limit_burst,omitempty"`

	// LogLevel
	// Logging level according to the syslogd-defined priorities.
	// The value can be strings or numbers from 1-8.
	// This parameter is only applicable if C(jump) is set to C(LOG).
	//
	// Default: <no value>
	// Required: false
	LogLevel string `yaml:"log_level,omitempty" json:"log_level,omitempty"`

	// LogPrefix
	// Specifies a log text for the rule. Only make sense with a LOG jump.
	//
	// Default: <no value>
	// Required: false
	LogPrefix string `yaml:"log_prefix,omitempty" json:"log_prefix,omitempty"`

	// Match
	// Specifies a match to use, that is, an extension module that tests for a specific property.
	// The set of matches make up the condition under which a target is invoked.
	// Matches are evaluated first to last if specified as an array and work in short-circuit fashion, i.e. if one extension yields false, evaluation will stop.
	//
	// Default: []
	// Required: false
	Match []string `yaml:"match,omitempty" json:"match,omitempty"`

	// MatchSet
	// Specifies a set name which can be defined by ipset.
	// Must be used together with the match_set_flags parameter.
	// When the C(!) argument is prepended then it inverts the rule.
	// Uses the iptables set extension.
	//
	// Default: <no value>
	// Required: false
	MatchSet string `yaml:"match_set,omitempty" json:"match_set,omitempty"`

	// MatchSetFlags
	// Specifies the necessary flags for the match_set parameter.
	// Must be used together with the match_set parameter.
	// Uses the iptables set extension.
	//
	// Default: <no value>
	// Required: false
	MatchSetFlags string `yaml:"match_set_flags,omitempty" json:"match_set_flags,omitempty"`

	// OutInterface
	// Name of an interface via which a packet is going to be sent (for packets entering the C(FORWARD), C(OUTPUT) and C(POSTROUTING) chains).
	// When the C(!) argument is used before the interface name, the sense is inverted.
	// If the interface name ends in a C(+), then any interface which begins with this name will match.
	// If this option is omitted, any interface name will match.
	//
	// Default: <no value>
	// Required: false
	OutInterface string `yaml:"out_interface,omitempty" json:"out_interface,omitempty"`

	// Policy
	// Set the policy for the chain to the given target.
	// Only built-in chains can have policies.
	// This parameter requires the C(chain) parameter.
	// If you specify this parameter, all other parameters will be ignored.
	// This parameter is used to set default policy for the given C(chain). Do not confuse this with C(jump) parameter.
	//
	// Default: <no value>
	// Required: false
	Policy string `yaml:"policy,omitempty" json:"policy,omitempty"`

	// Protocol
	// The protocol of the rule or of the packet to check.
	// The specified protocol can be one of C(tcp), C(udp), C(udplite), C(icmp), C(ipv6-icmp) or C(icmpv6), C(esp), C(ah), C(sctp) or the special keyword C(all), or it can be a numeric value, representing one of these protocols or a different one.
	// A protocol name from I(/etc/protocols) is also allowed.
	// A C(!) argument before the protocol inverts the test.
	// The number zero is equivalent to all.
	// C(all) will match with all protocols and is taken as default when this option is omitted.
	//
	// Default: <no value>
	// Required: false
	Protocol string `yaml:"protocol,omitempty" json:"protocol,omitempty"`

	// RejectWith
	// Specifies the error packet type to return while rejecting. It implies "jump: REJECT".
	//
	// Default: <no value>
	// Required: false
	RejectWith string `yaml:"reject_with,omitempty" json:"reject_with,omitempty"`

	// RuleNum
	// Insert the rule as the given rule number.
	// This works only with C(action=insert).
	//
	// Default: <no value>
	// Required: false
	RuleNum string `yaml:"rule_num,omitempty" json:"rule_num,omitempty"`

	// SetCounters
	// This enables the administrator to initialize the packet and byte counters of a rule (during C(INSERT), C(APPEND), C(REPLACE) operations).
	//
	// Default: <no value>
	// Required: false
	SetCounters string `yaml:"set_counters,omitempty" json:"set_counters,omitempty"`

	// SetDscpMark
	// This allows specifying a DSCP mark to be added to packets. It takes either an integer or hex value.
	// Mutually exclusive with C(set_dscp_mark_class).
	//
	// Default: <no value>
	// Required: false
	SetDscpMark string `yaml:"set_dscp_mark,omitempty" json:"set_dscp_mark,omitempty"`

	// SetDscpMarkClass
	// This allows specifying a predefined DiffServ class which will be translated to the corresponding DSCP mark.
	// Mutually exclusive with C(set_dscp_mark).
	//
	// Default: <no value>
	// Required: false
	SetDscpMarkClass string `yaml:"set_dscp_mark_class,omitempty" json:"set_dscp_mark_class,omitempty"`

	// Source
	// Source specification.
	// Address can be either a network name, a hostname, a network IP address (with /mask), or a plain IP address.
	// Hostnames will be resolved once only, before the rule is submitted to the kernel. Please note that specifying any name to be resolved with a remote query such as DNS is a really bad idea.
	// The mask can be either a network mask or a plain number, specifying the number of 1's at the left side of the network mask. Thus, a mask of 24 is equivalent to 255.255.255.0. A C(!) argument before the address specification inverts the sense of the address.
	//
	// Default: <no value>
	// Required: false
	Source string `yaml:"source,omitempty" json:"source,omitempty"`

	// SourcePort
	// Source port or port range specification.
	// This can either be a service name or a port number.
	// An inclusive range can also be specified, using the format C(first:last).
	// If the first port is omitted, C(0) is assumed; if the last is omitted, C(65535) is assumed.
	// If the first port is greater than the second one they will be swapped.
	//
	// Default: <no value>
	// Required: false
	SourcePort string `yaml:"source_port,omitempty" json:"source_port,omitempty"`

	// SrcRange
	// Specifies the source IP range to match in the iprange module.
	//
	// Default: <no value>
	// Required: false
	SrcRange string `yaml:"src_range,omitempty" json:"src_range,omitempty"`

	// State
	// Whether the rule should be absent or present.
	//
	// Default: present
	// Required: false
	State string `yaml:"state,omitempty" json:"state,omitempty"`

	// Syn
	// This allows matching packets that have the SYN bit set and the ACK and RST bits unset.
	// When negated, this matches all packets with the RST or the ACK bits set.
	//
	// Default: ignore
	// Required: false
	Syn string `yaml:"syn,omitempty" json:"syn,omitempty"`

	// Table
	// This option specifies the packet matching table which the command should operate on.
	// If the kernel is configured with automatic module loading, an attempt will be made to load the appropriate module for that table if it is not already there.
	//
	// Default: filter
	// Required: false
	Table string `yaml:"table,omitempty" json:"table,omitempty"`

	// TcpFlags
	// TCP flags specification.
	// C(tcp_flags) expects a dict with the two keys C(flags) and C(flags_set).
	//
	// Default: map[]
	// Required: false
	TcpFlags map[string]string `yaml:"tcp_flags,omitempty" json:"tcp_flags,omitempty"`

	// ToDestination
	// This specifies a destination address to use with C(DNAT).
	// Without this, the destination address is never altered.
	//
	// Default: <no value>
	// Required: false
	ToDestination string `yaml:"to_destination,omitempty" json:"to_destination,omitempty"`

	// ToPorts
	// This specifies a destination port or range of ports to use, without this, the destination port is never altered.
	// This is only valid if the rule also specifies one of the protocol C(tcp), C(udp), C(dccp) or C(sctp).
	//
	// Default: <no value>
	// Required: false
	ToPorts string `yaml:"to_ports,omitempty" json:"to_ports,omitempty"`

	// ToSource
	// This specifies a source address to use with C(SNAT).
	// Without this, the source address is never altered.
	//
	// Default: <no value>
	// Required: false
	ToSource string `yaml:"to_source,omitempty" json:"to_source,omitempty"`

	// UidOwner
	// Specifies the UID or username to use in match by owner rule.
	// From Ansible 2.6 when the C(!) argument is prepended then the it inverts the rule to apply instead to all users except that one specified.
	//
	// Default: <no value>
	// Required: false
	UidOwner string `yaml:"uid_owner,omitempty" json:"uid_owner,omitempty"`

	// Wait
	// Wait N seconds for the xtables lock to prevent multiple instances of the program from running concurrently.
	//
	// Default: <no value>
	// Required: false
	Wait string `yaml:"wait,omitempty" json:"wait,omitempty"`

	values map[string]types.Value
}

func (p *IptablesParams) Names() []string {
	names := []string{}
	for name := range p.values {
		names = append(names, name)
	}
	return []string{}
}

func (p *IptablesParams) Set(name string, value interface{}) error {
	v, ok := p.values[name]
	if !ok {
		return fmt.Errorf("no param with name %q", name)
	}
	return v.Set(value)
}

func (p *IptablesParams) Get(name string) (interface{}, error) {
	v, ok := p.values[name]
	if !ok {
		return nil, fmt.Errorf("no param with name %q", name)
	}
	return v.Get(), nil
}

type IptablesResult struct {
	types.CommonReturn
	Raw string

	values map[string]types.Value
}

func (r *IptablesResult) Names() []string {
	names := []string{}
	for name := range r.values {
		names = append(names, name)
	}
	return []string{}
}

func (r *IptablesResult) Set(name string, value interface{}) error {
	v, ok := r.values[name]
	if !ok {
		return fmt.Errorf("no param with name %q", name)
	}
	return v.Set(value)
}

func (r *IptablesResult) Get(name string) (interface{}, error) {
	v, ok := r.values[name]
	if !ok {
		return nil, fmt.Errorf("no param with name %q", name)
	}
	return v.Get(), nil
}

func (m *Iptables) GetResult() types.Result {
	return &m.Result
}

func (m *Iptables) GetResultRaw() string {
	return m.Result.Raw
}

func (m *Iptables) GetCommonResult() types.CommonReturn {
	return m.Result.CommonReturn
}

func (m *Iptables) GetParams() types.Params {
	return &m.Params
}

func (m *Iptables) GetType() string {
	return "iptables"
}
