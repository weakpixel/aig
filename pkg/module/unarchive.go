package module

// Autogenerated file

import (
	"github.com/weakpixel/aig/pkg/types"
)

func init() {
	addModuleFactory("unarchive", func() Module {
		return NewUnarchive()
	})
}

//
// Unarchive (unarchive) - Unpacks an archive after (optionally) copying it from the local machine
//
func NewUnarchive() *Unarchive {
	return &Unarchive{}
}

// Unarchive (unarchive) - Unpacks an archive after (optionally) copying it from the local machine
//
// The C(unarchive) module unpacks an archive. It will not unpack a compressed file that does not contain an archive.
// By default, it will copy the source file from the local system to the target before unpacking.
// Set C(remote_src=yes) to unpack an archive which already exists on the target.
// If checksum validation is desired, use M(ansible.builtin.get_url) or M(ansible.builtin.uri) instead to fetch the file and set C(remote_src=yes).
// For Windows targets, use the M(community.windows.win_unzip) module instead.
type Unarchive struct {
	Params UnarchiveParams
	Result UnarchiveResult
}

type UnarchiveParams struct {

	// Copy
	// If true, the file is copied from local controller to the managed (remote) node, otherwise, the plugin will look for src archive on the managed machine.
	// This option has been deprecated in favor of C(remote_src).
	// This option is mutually exclusive with C(remote_src).
	//
	// Default: yes
	// Required: false
	Copy bool `yaml:"copy,omitempty" json:"copy,omitempty"`

	// Creates
	// If the specified absolute path (file or directory) already exists, this step will B(not) be run.
	//
	// Default: <no value>
	// Required: false
	Creates string `yaml:"creates,omitempty" json:"creates,omitempty"`

	// Dest
	// Remote absolute path where the archive should be unpacked.
	//
	// Default: <no value>
	// Required: true
	Dest string `yaml:"dest,omitempty" json:"dest,omitempty"`

	// Exclude
	// List the directory and file entries that you would like to exclude from the unarchive action.
	// Mutually exclusive with C(include).
	//
	// Default: []
	// Required: false
	Exclude []string `yaml:"exclude,omitempty" json:"exclude,omitempty"`

	// ExtraOpts
	// Specify additional options by passing in an array.
	// Each space-separated command-line option should be a new element of the array. See examples.
	// Command-line options with multiple elements must use multiple lines in the array, one for each element.
	//
	// Default:
	// Required: false
	ExtraOpts []string `yaml:"extra_opts,omitempty" json:"extra_opts,omitempty"`

	// Include
	// List of directory and file entries that you would like to extract from the archive. If C(include) is not empty, only files listed here will be extracted.
	// Mutually exclusive with C(exclude).
	//
	// Default: []
	// Required: false
	Include []string `yaml:"include,omitempty" json:"include,omitempty"`

	// IoBufferSize
	// Size of the volatile memory buffer that is used for extracting files from the archive in bytes.
	//
	// Default: 65536
	// Required: false
	IoBufferSize int `yaml:"io_buffer_size,omitempty" json:"io_buffer_size,omitempty"`

	// KeepNewer
	// Do not replace existing files that are newer than files from the archive.
	//
	// Default: no
	// Required: false
	KeepNewer bool `yaml:"keep_newer,omitempty" json:"keep_newer,omitempty"`

	// ListFiles
	// If set to True, return the list of files that are contained in the tarball.
	//
	// Default: no
	// Required: false
	ListFiles bool `yaml:"list_files,omitempty" json:"list_files,omitempty"`

	// RemoteSrc
	// Set to C(yes) to indicate the archived file is already on the remote system and not local to the Ansible controller.
	// This option is mutually exclusive with C(copy).
	//
	// Default: no
	// Required: false
	RemoteSrc bool `yaml:"remote_src,omitempty" json:"remote_src,omitempty"`

	// Src
	// If C(remote_src=no) (default), local path to archive file to copy to the target server; can be absolute or relative. If C(remote_src=yes), path on the target server to existing archive file to unpack.
	// If C(remote_src=yes) and C(src) contains C(://), the remote machine will download the file from the URL first. (version_added 2.0). This is only for simple cases, for full download support use the M(ansible.builtin.get_url) module.
	//
	// Default: <no value>
	// Required: true
	Src string `yaml:"src,omitempty" json:"src,omitempty"`

	// ValidateCerts
	// This only applies if using a https URL as the source of the file.
	// This should only set to C(no) used on personally controlled sites using self-signed certificate.
	// Prior to 2.2 the code worked as if this was set to C(yes).
	//
	// Default: yes
	// Required: false
	ValidateCerts bool `yaml:"validate_certs,omitempty" json:"validate_certs,omitempty"`
}

type UnarchiveResult struct {
	types.CommonReturn
	Raw string

	// Dest
	// Path to the destination directory.
	Dest string `yaml:"dest,omitempty" json:"dest,omitempty"`

	// Files
	// List of all the files in the archive.
	Files []map[string]interface{} `yaml:"files,omitempty" json:"files,omitempty"`

	// Gid
	// Numerical ID of the group that owns the destination directory.
	Gid int `yaml:"gid,omitempty" json:"gid,omitempty"`

	// Group
	// Name of the group that owns the destination directory.
	Group string `yaml:"group,omitempty" json:"group,omitempty"`

	// Handler
	// Archive software handler used to extract and decompress the archive.
	Handler string `yaml:"handler,omitempty" json:"handler,omitempty"`

	// Mode
	// String that represents the octal permissions of the destination directory.
	Mode string `yaml:"mode,omitempty" json:"mode,omitempty"`

	// Owner
	// Name of the user that owns the destination directory.
	Owner string `yaml:"owner,omitempty" json:"owner,omitempty"`

	// Size
	// The size of destination directory in bytes. Does not include the size of files or subdirectories contained within.
	Size int `yaml:"size,omitempty" json:"size,omitempty"`

	// Src
	Src string `yaml:"src,omitempty" json:"src,omitempty"`

	// State
	// State of the destination. Effectively always "directory".
	State string `yaml:"state,omitempty" json:"state,omitempty"`

	// Uid
	// Numerical ID of the user that owns the destination directory.
	Uid int `yaml:"uid,omitempty" json:"uid,omitempty"`
}

func (m *Unarchive) GetResult() interface{} {
	return &m.Result
}

func (m *Unarchive) GetResultRaw() string {
	return m.Result.Raw
}

func (m *Unarchive) GetCommonResult() types.CommonReturn {
	return m.Result.CommonReturn
}

func (m *Unarchive) GetParams() interface{} {
	return &m.Params
}

func (m *Unarchive) GetType() string {
	return "unarchive"
}
