package module

// Autogenerated file

import (
	"fmt"
	"github.com/weakpixel/aig/pkg/types"
)

func init() {
	addModuleFactory("unarchive", func() types.Module {
		return NewUnarchive()
	})
}

//
// Unarchive (unarchive) - Unpacks an archive after (optionally) copying it from the local machine
//
func NewUnarchive() *Unarchive {
	module := Unarchive{}
	// Create dynamic param values
	paramValues := map[string]types.Value{}
	paramValues["copy"] = types.NewBoolValue(&module.Params.Copy)
	paramValues["creates"] = types.NewStringValue(&module.Params.Creates)
	paramValues["dest"] = types.NewStringValue(&module.Params.Dest)
	paramValues["exclude"] = types.NewStringListValue(&module.Params.Exclude)
	paramValues["extra_opts"] = types.NewStringListValue(&module.Params.ExtraOpts)
	paramValues["include"] = types.NewStringListValue(&module.Params.Include)
	paramValues["io_buffer_size"] = types.NewIntValue(&module.Params.IoBufferSize)
	paramValues["keep_newer"] = types.NewBoolValue(&module.Params.KeepNewer)
	paramValues["list_files"] = types.NewBoolValue(&module.Params.ListFiles)
	paramValues["remote_src"] = types.NewBoolValue(&module.Params.RemoteSrc)
	paramValues["src"] = types.NewStringValue(&module.Params.Src)
	paramValues["validate_certs"] = types.NewBoolValue(&module.Params.ValidateCerts)
	module.Params.values = paramValues

	// Create dynamic result values
	resultValues := map[string]types.Value{}

	resultValues["dest"] = types.NewStringValue(&module.Result.Dest)
	resultValues["files"] = types.NewStringListValue(&module.Result.Files)
	resultValues["gid"] = types.NewIntValue(&module.Result.Gid)
	resultValues["group"] = types.NewStringValue(&module.Result.Group)
	resultValues["handler"] = types.NewStringValue(&module.Result.Handler)
	resultValues["mode"] = types.NewStringValue(&module.Result.Mode)
	resultValues["owner"] = types.NewStringValue(&module.Result.Owner)
	resultValues["size"] = types.NewIntValue(&module.Result.Size)
	resultValues["src"] = types.NewStringValue(&module.Result.Src)
	resultValues["state"] = types.NewStringValue(&module.Result.State)
	resultValues["uid"] = types.NewIntValue(&module.Result.Uid)
	module.Result.values = resultValues

	return &module
}

// Unarchive (unarchive) - Unpacks an archive after (optionally) copying it from the local machine
//
// The C(unarchive) module unpacks an archive. It will not unpack a compressed file that does not contain an archive.
//
// By default, it will copy the source file from the local system to the target before unpacking.
//
// Set C(remote_src=yes) to unpack an archive which already exists on the target.
//
// If checksum validation is desired, use M(ansible.builtin.get_url) or M(ansible.builtin.uri) instead to fetch the file and set C(remote_src=yes).
//
// For Windows targets, use the M(community.windows.win_unzip) module instead.
//
//
// Source: https://github.com/ansible/ansible/blob/v2.13.1/lib/ansible/modules/unarchive.py
type Unarchive struct {
	Params UnarchiveParams
	Result UnarchiveResult
}

type UnarchiveParams struct {

	// Copy
	// If true, the file is copied from local controller to the managed (remote) node, otherwise, the plugin will look for src archive on the managed machine.
	// This option has been deprecated in favor of C(remote_src).
	// This option is mutually exclusive with C(remote_src).
	//
	// Default: yes
	// Required: false
	Copy bool `yaml:"copy,omitempty" json:"copy,omitempty" cty:"copy"`

	// Creates
	// If the specified absolute path (file or directory) already exists, this step will B(not) be run.
	//
	// Default: <no value>
	// Required: false
	Creates string `yaml:"creates,omitempty" json:"creates,omitempty" cty:"creates"`

	// Dest
	// Remote absolute path where the archive should be unpacked.
	//
	// Default: <no value>
	// Required: true
	Dest string `yaml:"dest,omitempty" json:"dest,omitempty" cty:"dest"`

	// Exclude
	// List the directory and file entries that you would like to exclude from the unarchive action.
	// Mutually exclusive with C(include).
	//
	// Default: []
	// Required: false
	Exclude []string `yaml:"exclude,omitempty" json:"exclude,omitempty" cty:"exclude"`

	// ExtraOpts
	// Specify additional options by passing in an array.
	// Each space-separated command-line option should be a new element of the array. See examples.
	// Command-line options with multiple elements must use multiple lines in the array, one for each element.
	//
	// Default:
	// Required: false
	ExtraOpts []string `yaml:"extra_opts,omitempty" json:"extra_opts,omitempty" cty:"extra_opts"`

	// Include
	// List of directory and file entries that you would like to extract from the archive. If C(include) is not empty, only files listed here will be extracted.
	// Mutually exclusive with C(exclude).
	//
	// Default: []
	// Required: false
	Include []string `yaml:"include,omitempty" json:"include,omitempty" cty:"include"`

	// IoBufferSize
	// Size of the volatile memory buffer that is used for extracting files from the archive in bytes.
	//
	// Default: 65536
	// Required: false
	IoBufferSize int `yaml:"io_buffer_size,omitempty" json:"io_buffer_size,omitempty" cty:"io_buffer_size"`

	// KeepNewer
	// Do not replace existing files that are newer than files from the archive.
	//
	// Default: no
	// Required: false
	KeepNewer bool `yaml:"keep_newer,omitempty" json:"keep_newer,omitempty" cty:"keep_newer"`

	// ListFiles
	// If set to True, return the list of files that are contained in the tarball.
	//
	// Default: no
	// Required: false
	ListFiles bool `yaml:"list_files,omitempty" json:"list_files,omitempty" cty:"list_files"`

	// RemoteSrc
	// Set to C(yes) to indicate the archived file is already on the remote system and not local to the Ansible controller.
	// This option is mutually exclusive with C(copy).
	//
	// Default: no
	// Required: false
	RemoteSrc bool `yaml:"remote_src,omitempty" json:"remote_src,omitempty" cty:"remote_src"`

	// Src
	// If C(remote_src=no) (default), local path to archive file to copy to the target server; can be absolute or relative. If C(remote_src=yes), path on the target server to existing archive file to unpack.
	// If C(remote_src=yes) and C(src) contains C(://), the remote machine will download the file from the URL first. (version_added 2.0). This is only for simple cases, for full download support use the M(ansible.builtin.get_url) module.
	//
	// Default: <no value>
	// Required: true
	Src string `yaml:"src,omitempty" json:"src,omitempty" cty:"src"`

	// ValidateCerts
	// This only applies if using a https URL as the source of the file.
	// This should only set to C(no) used on personally controlled sites using self-signed certificate.
	// Prior to 2.2 the code worked as if this was set to C(yes).
	//
	// Default: yes
	// Required: false
	ValidateCerts bool `yaml:"validate_certs,omitempty" json:"validate_certs,omitempty" cty:"validate_certs"`

	values map[string]types.Value
}

func (p *UnarchiveParams) Names() []string {
	names := []string{}
	for name := range p.values {
		names = append(names, name)
	}
	return names
}

func (p *UnarchiveParams) Set(name string, value interface{}) error {
	v, ok := p.values[name]
	if !ok {
		return fmt.Errorf("no param with name %q", name)
	}
	return v.Set(value)
}

func (p *UnarchiveParams) Get(name string) (interface{}, error) {
	v, ok := p.values[name]
	if !ok {
		return nil, fmt.Errorf("no param with name %q", name)
	}
	return v.Get(), nil
}

type UnarchiveResult struct {
	types.CommonReturn
	Raw string

	// Dest
	// Path to the destination directory.
	Dest string `yaml:"dest,omitempty" json:"dest,omitempty" cty:"dest"`

	// Files
	// List of all the files in the archive.
	Files []string `yaml:"files,omitempty" json:"files,omitempty" cty:"files"`

	// Gid
	// Numerical ID of the group that owns the destination directory.
	Gid int `yaml:"gid,omitempty" json:"gid,omitempty" cty:"gid"`

	// Group
	// Name of the group that owns the destination directory.
	Group string `yaml:"group,omitempty" json:"group,omitempty" cty:"group"`

	// Handler
	// Archive software handler used to extract and decompress the archive.
	Handler string `yaml:"handler,omitempty" json:"handler,omitempty" cty:"handler"`

	// Mode
	// String that represents the octal permissions of the destination directory.
	Mode string `yaml:"mode,omitempty" json:"mode,omitempty" cty:"mode"`

	// Owner
	// Name of the user that owns the destination directory.
	Owner string `yaml:"owner,omitempty" json:"owner,omitempty" cty:"owner"`

	// Size
	// The size of destination directory in bytes. Does not include the size of files or subdirectories contained within.
	Size int `yaml:"size,omitempty" json:"size,omitempty" cty:"size"`

	// Src
	Src string `yaml:"src,omitempty" json:"src,omitempty" cty:"src"`

	// State
	// State of the destination. Effectively always "directory".
	State string `yaml:"state,omitempty" json:"state,omitempty" cty:"state"`

	// Uid
	// Numerical ID of the user that owns the destination directory.
	Uid int `yaml:"uid,omitempty" json:"uid,omitempty" cty:"uid"`

	values map[string]types.Value
}

func (r *UnarchiveResult) Names() []string {
	names := []string{}
	for name := range r.values {
		names = append(names, name)
	}
	return names
}

func (r *UnarchiveResult) Set(name string, value interface{}) error {
	v, ok := r.values[name]
	if !ok {
		return fmt.Errorf("no param with name %q", name)
	}
	return v.Set(value)
}

func (r *UnarchiveResult) Get(name string) (interface{}, error) {
	v, ok := r.values[name]
	if !ok {
		return nil, fmt.Errorf("no param with name %q", name)
	}
	return v.Get(), nil
}

func (m *Unarchive) GetResult() types.Result {
	return &m.Result
}

func (m *Unarchive) GetResultRaw() string {
	return m.Result.Raw
}

func (m *Unarchive) GetCommonResult() types.CommonReturn {
	return m.Result.CommonReturn
}

func (m *Unarchive) GetParams() types.Params {
	return &m.Params
}

func (m *Unarchive) GetType() string {
	return "unarchive"
}
