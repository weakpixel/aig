package module

// Autogenerated file

import (
	"github.com/weakpixel/aig/pkg/types"
)

func init() {
	addModuleFactory("service", func() Module {
		return NewService()
	})
}

//
// Service (service) - Manage services
//
func NewService() *Service {
	return &Service{}
}

// Service (service) - Manage services
//
// Controls services on remote hosts. Supported init systems include BSD init, OpenRC, SysV, Solaris SMF, systemd, upstart.
// This module acts as a proxy to the underlying service manager module. While all arguments will be passed to the underlying module, not all modules support the same arguments. This documentation only covers the minimum intersection of module arguments that all service manager modules support.
// This module is a proxy for multiple more specific service manager modules (such as M(ansible.builtin.systemd) and M(ansible.builtin.sysvinit)). This allows management of a heterogeneous environment of machines without creating a specific task for each service manager. The module to be executed is determined by the I(use) option, which defaults to the service manager discovered by M(ansible.builtin.setup).  If C(setup) was not yet run, this module may run it.
// For Windows targets, use the M(ansible.windows.win_service) module instead.
type Service struct {
	Params ServiceParams
	Result ServiceResult
}

type ServiceParams struct {

	// Arguments
	// Additional arguments provided on the command line.
	// While using remote hosts with systemd this setting will be ignored.
	//
	// Default: <no value>
	// Required: false
	Arguments string `yaml:"arguments,omitempty" json:"arguments,omitempty"`

	// Enabled
	// Whether the service should start on boot.
	// B(At least one of state and enabled are required.)
	//
	// Default: <no value>
	// Required: false
	Enabled bool `yaml:"enabled,omitempty" json:"enabled,omitempty"`

	// Name
	// Name of the service.
	//
	// Default: <no value>
	// Required: true
	Name string `yaml:"name,omitempty" json:"name,omitempty"`

	// Pattern
	// If the service does not respond to the status command, name a substring to look for as would be found in the output of the I(ps) command as a stand-in for a status result.
	// If the string is found, the service will be assumed to be started.
	// While using remote hosts with systemd this setting will be ignored.
	//
	// Default: <no value>
	// Required: false
	Pattern string `yaml:"pattern,omitempty" json:"pattern,omitempty"`

	// Runlevel
	// For OpenRC init scripts (e.g. Gentoo) only.
	// The runlevel that this service belongs to.
	// While using remote hosts with systemd this setting will be ignored.
	//
	// Default: default
	// Required: false
	Runlevel string `yaml:"runlevel,omitempty" json:"runlevel,omitempty"`

	// Sleep
	// If the service is being C(restarted) then sleep this many seconds between the stop and start command.
	// This helps to work around badly-behaving init scripts that exit immediately after signaling a process to stop.
	// Not all service managers support sleep, i.e when using systemd this setting will be ignored.
	//
	// Default: <no value>
	// Required: false
	Sleep int `yaml:"sleep,omitempty" json:"sleep,omitempty"`

	// State
	// C(started)/C(stopped) are idempotent actions that will not run commands unless necessary.
	// C(restarted) will always bounce the service.
	// C(reloaded) will always reload.
	// B(At least one of state and enabled are required.)
	// Note that reloaded will start the service if it is not already started, even if your chosen init system wouldn't normally.
	//
	// Default: <no value>
	// Required: false
	State string `yaml:"state,omitempty" json:"state,omitempty"`

	// Use
	// The service module actually uses system specific modules, normally through auto detection, this setting can force a specific module.
	// Normally it uses the value of the 'ansible_service_mgr' fact and falls back to the old 'service' module when none matching is found.
	//
	// Default: auto
	// Required: false
	Use string `yaml:"use,omitempty" json:"use,omitempty"`
}

type ServiceResult struct {
	types.CommonReturn
	Raw string
}

func (m *Service) GetResult() interface{} {
	return &m.Result
}

func (m *Service) GetResultRaw() string {
	return m.Result.Raw
}

func (m *Service) GetCommonResult() types.CommonReturn {
	return m.Result.CommonReturn
}

func (m *Service) GetParams() interface{} {
	return &m.Params
}

func (m *Service) GetType() string {
	return "service"
}
