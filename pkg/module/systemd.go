package module

// Autogenerated file

import (
	"github.com/weakpixel/aig/pkg/types"
)

func init() {
	addModuleFactory("systemd", func() Module {
		return NewSystemd()
	})
}

//
// Systemd (systemd) - Manage systemd units
//
func NewSystemd() *Systemd {
	return &Systemd{}
}

// Systemd (systemd) - Manage systemd units
//
// Controls systemd units (services, timers, and so on) on remote hosts.
type Systemd struct {
	Params SystemdParams
	Result SystemdResult
}

type SystemdParams struct {

	// DaemonReexec
	// Run daemon_reexec command before doing any other operations, the systemd manager will serialize the manager state.
	//
	// Default: no
	// Required: false
	DaemonReexec bool `yaml:"daemon_reexec,omitempty" json:"daemon_reexec,omitempty"`

	// DaemonReload
	// Run daemon-reload before doing any other operations, to make sure systemd has read any changes.
	// When set to C(true), runs daemon-reload even if the module does not start or stop anything.
	//
	// Default: no
	// Required: false
	DaemonReload bool `yaml:"daemon_reload,omitempty" json:"daemon_reload,omitempty"`

	// Enabled
	// Whether the unit should start on boot. B(At least one of state and enabled are required.)
	//
	// Default: <no value>
	// Required: false
	Enabled bool `yaml:"enabled,omitempty" json:"enabled,omitempty"`

	// Force
	// Whether to override existing symlinks.
	//
	// Default: <no value>
	// Required: false
	Force bool `yaml:"force,omitempty" json:"force,omitempty"`

	// Masked
	// Whether the unit should be masked or not, a masked unit is impossible to start.
	//
	// Default: <no value>
	// Required: false
	Masked bool `yaml:"masked,omitempty" json:"masked,omitempty"`

	// Name
	// Name of the unit. This parameter takes the name of exactly one unit to work with.
	// When no extension is given, it is implied to a C(.service) as systemd.
	// When using in a chroot environment you always need to specify the name of the unit with the extension. For example, C(crond.service).
	//
	// Default: <no value>
	// Required: false
	Name string `yaml:"name,omitempty" json:"name,omitempty"`

	// NoBlock
	// Do not synchronously wait for the requested operation to finish. Enqueued job will continue without Ansible blocking on its completion.
	//
	// Default: no
	// Required: false
	NoBlock bool `yaml:"no_block,omitempty" json:"no_block,omitempty"`

	// Scope
	// Run systemctl within a given service manager scope, either as the default system scope C(system), the current user's scope C(user), or the scope of all users C(global).
	// For systemd to work with 'user', the executing user must have its own instance of dbus started and accessible (systemd requirement).
	// The user dbus process is normally started during normal login, but not during the run of Ansible tasks. Otherwise you will probably get a 'Failed to connect to bus: no such file or directory' error.
	// The user must have access, normally given via setting the C(XDG_RUNTIME_DIR) variable, see example below.
	//
	// Default: system
	// Required: false
	Scope string `yaml:"scope,omitempty" json:"scope,omitempty"`

	// State
	// C(started)/C(stopped) are idempotent actions that will not run commands unless necessary. C(restarted) will always bounce the unit. C(reloaded) will always reload.
	//
	// Default: <no value>
	// Required: false
	State string `yaml:"state,omitempty" json:"state,omitempty"`
}

type SystemdResult struct {
	types.CommonReturn
	Raw string

	// Status
	// A dictionary with the key=value pairs returned from C(systemctl show).
	Status interface{} `yaml:"status,omitempty" json:"status,omitempty"`
}

func (m *Systemd) GetResult() interface{} {
	return &m.Result
}

func (m *Systemd) GetResultRaw() string {
	return m.Result.Raw
}

func (m *Systemd) GetCommonResult() types.CommonReturn {
	return m.Result.CommonReturn
}

func (m *Systemd) GetParams() interface{} {
	return &m.Params
}

func (m *Systemd) GetType() string {
	return "systemd"
}
