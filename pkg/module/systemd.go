package module

// Autogenerated file

import (
	"fmt"
	"github.com/weakpixel/aig/pkg/types"
)

func init() {
	addModuleFactory("systemd", func() types.Module {
		return NewSystemd()
	})
}

//
// Systemd (systemd) - Manage systemd units
//
func NewSystemd() *Systemd {
	module := Systemd{}
	// Create dynamic param values
	paramValues := map[string]types.Value{}
	paramValues["daemon_reexec"] = types.NewBoolValue(&module.Params.DaemonReexec)
	paramValues["daemon_reload"] = types.NewBoolValue(&module.Params.DaemonReload)
	paramValues["enabled"] = types.NewBoolValue(&module.Params.Enabled)
	paramValues["force"] = types.NewBoolValue(&module.Params.Force)
	paramValues["masked"] = types.NewBoolValue(&module.Params.Masked)
	paramValues["name"] = types.NewStringValue(&module.Params.Name)
	paramValues["no_block"] = types.NewBoolValue(&module.Params.NoBlock)
	paramValues["scope"] = types.NewStringValue(&module.Params.Scope)
	paramValues["state"] = types.NewStringValue(&module.Params.State)
	module.Params.values = paramValues

	// Create dynamic result values
	resultValues := map[string]types.Value{}

	// NOT SUPPORTED: status Status interface{}
	module.Result.values = resultValues

	return &module
}

// Systemd (systemd) - Manage systemd units
//
// Controls systemd units (services, timers, and so on) on remote hosts.
//
//
// Source: https://github.com/ansible/ansible/blob/v2.13.1/lib/ansible/modules/systemd.py
type Systemd struct {
	Params SystemdParams
	Result SystemdResult
}

type SystemdParams struct {

	// DaemonReexec
	// Run daemon_reexec command before doing any other operations, the systemd manager will serialize the manager state.
	//
	// Default: no
	// Required: false
	DaemonReexec bool `yaml:"daemon_reexec,omitempty" json:"daemon_reexec,omitempty"`

	// DaemonReload
	// Run daemon-reload before doing any other operations, to make sure systemd has read any changes.
	// When set to C(true), runs daemon-reload even if the module does not start or stop anything.
	//
	// Default: no
	// Required: false
	DaemonReload bool `yaml:"daemon_reload,omitempty" json:"daemon_reload,omitempty"`

	// Enabled
	// Whether the unit should start on boot. B(At least one of state and enabled are required.)
	//
	// Default: <no value>
	// Required: false
	Enabled bool `yaml:"enabled,omitempty" json:"enabled,omitempty"`

	// Force
	// Whether to override existing symlinks.
	//
	// Default: <no value>
	// Required: false
	Force bool `yaml:"force,omitempty" json:"force,omitempty"`

	// Masked
	// Whether the unit should be masked or not, a masked unit is impossible to start.
	//
	// Default: <no value>
	// Required: false
	Masked bool `yaml:"masked,omitempty" json:"masked,omitempty"`

	// Name
	// Name of the unit. This parameter takes the name of exactly one unit to work with.
	// When no extension is given, it is implied to a C(.service) as systemd.
	// When using in a chroot environment you always need to specify the name of the unit with the extension. For example, C(crond.service).
	//
	// Default: <no value>
	// Required: false
	Name string `yaml:"name,omitempty" json:"name,omitempty"`

	// NoBlock
	// Do not synchronously wait for the requested operation to finish. Enqueued job will continue without Ansible blocking on its completion.
	//
	// Default: no
	// Required: false
	NoBlock bool `yaml:"no_block,omitempty" json:"no_block,omitempty"`

	// Scope
	// Run systemctl within a given service manager scope, either as the default system scope C(system), the current user's scope C(user), or the scope of all users C(global).
	// For systemd to work with 'user', the executing user must have its own instance of dbus started and accessible (systemd requirement).
	// The user dbus process is normally started during normal login, but not during the run of Ansible tasks. Otherwise you will probably get a 'Failed to connect to bus: no such file or directory' error.
	// The user must have access, normally given via setting the C(XDG_RUNTIME_DIR) variable, see example below.
	//
	// Default: system
	// Required: false
	Scope string `yaml:"scope,omitempty" json:"scope,omitempty"`

	// State
	// C(started)/C(stopped) are idempotent actions that will not run commands unless necessary. C(restarted) will always bounce the unit. C(reloaded) will always reload.
	//
	// Default: <no value>
	// Required: false
	State string `yaml:"state,omitempty" json:"state,omitempty"`

	values map[string]types.Value
}

func (p *SystemdParams) Names() []string {
	names := []string{}
	for name := range p.values {
		names = append(names, name)
	}
	return []string{}
}

func (p *SystemdParams) Set(name string, value interface{}) error {
	v, ok := p.values[name]
	if !ok {
		return fmt.Errorf("no param with name %q", name)
	}
	return v.Set(value)
}

func (p *SystemdParams) Get(name string) (interface{}, error) {
	v, ok := p.values[name]
	if !ok {
		return nil, fmt.Errorf("no param with name %q", name)
	}
	return v.Get(), nil
}

type SystemdResult struct {
	types.CommonReturn
	Raw string

	// Status
	// A dictionary with the key=value pairs returned from C(systemctl show).
	Status interface{} `yaml:"status,omitempty" json:"status,omitempty"`

	values map[string]types.Value
}

func (r *SystemdResult) Names() []string {
	names := []string{}
	for name := range r.values {
		names = append(names, name)
	}
	return []string{}
}

func (r *SystemdResult) Set(name string, value interface{}) error {
	v, ok := r.values[name]
	if !ok {
		return fmt.Errorf("no param with name %q", name)
	}
	return v.Set(value)
}

func (r *SystemdResult) Get(name string) (interface{}, error) {
	v, ok := r.values[name]
	if !ok {
		return nil, fmt.Errorf("no param with name %q", name)
	}
	return v.Get(), nil
}

func (m *Systemd) GetResult() types.Result {
	return &m.Result
}

func (m *Systemd) GetResultRaw() string {
	return m.Result.Raw
}

func (m *Systemd) GetCommonResult() types.CommonReturn {
	return m.Result.CommonReturn
}

func (m *Systemd) GetParams() types.Params {
	return &m.Params
}

func (m *Systemd) GetType() string {
	return "systemd"
}
