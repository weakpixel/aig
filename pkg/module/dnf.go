package module

// Autogenerated file

import (
	"fmt"
	"github.com/weakpixel/aig/pkg/types"
)

func init() {
	addModuleFactory("dnf", func() types.Module {
		return NewDnf()
	})
}

//
// Dnf (dnf) - Manages packages with the I(dnf) package manager
//
func NewDnf() *Dnf {
	module := Dnf{}
	// Create dynamic param values
	paramValues := map[string]types.Value{}
	paramValues["allow_downgrade"] = types.NewBoolValue(&module.Params.AllowDowngrade)
	paramValues["allowerasing"] = types.NewBoolValue(&module.Params.Allowerasing)
	paramValues["autoremove"] = types.NewBoolValue(&module.Params.Autoremove)
	paramValues["bugfix"] = types.NewBoolValue(&module.Params.Bugfix)
	paramValues["cacheonly"] = types.NewBoolValue(&module.Params.Cacheonly)
	paramValues["conf_file"] = types.NewStringValue(&module.Params.ConfFile)
	paramValues["disable_excludes"] = types.NewStringValue(&module.Params.DisableExcludes)
	paramValues["disable_gpg_check"] = types.NewBoolValue(&module.Params.DisableGpgCheck)
	paramValues["disable_plugin"] = types.NewStringListValue(&module.Params.DisablePlugin)
	paramValues["disablerepo"] = types.NewStringListValue(&module.Params.Disablerepo)
	paramValues["download_dir"] = types.NewStringValue(&module.Params.DownloadDir)
	paramValues["download_only"] = types.NewBoolValue(&module.Params.DownloadOnly)
	paramValues["enable_plugin"] = types.NewStringListValue(&module.Params.EnablePlugin)
	paramValues["enablerepo"] = types.NewStringListValue(&module.Params.Enablerepo)
	paramValues["exclude"] = types.NewStringListValue(&module.Params.Exclude)
	paramValues["install_repoquery"] = types.NewBoolValue(&module.Params.InstallRepoquery)
	paramValues["install_weak_deps"] = types.NewBoolValue(&module.Params.InstallWeakDeps)
	paramValues["installroot"] = types.NewStringValue(&module.Params.Installroot)
	paramValues["list"] = types.NewStringValue(&module.Params.List)
	paramValues["lock_timeout"] = types.NewIntValue(&module.Params.LockTimeout)
	paramValues["name"] = types.NewStringListValue(&module.Params.Name)
	paramValues["nobest"] = types.NewBoolValue(&module.Params.Nobest)
	paramValues["releasever"] = types.NewStringValue(&module.Params.Releasever)
	paramValues["security"] = types.NewBoolValue(&module.Params.Security)
	paramValues["skip_broken"] = types.NewBoolValue(&module.Params.SkipBroken)
	paramValues["sslverify"] = types.NewBoolValue(&module.Params.Sslverify)
	paramValues["state"] = types.NewStringValue(&module.Params.State)
	paramValues["update_cache"] = types.NewBoolValue(&module.Params.UpdateCache)
	paramValues["update_only"] = types.NewBoolValue(&module.Params.UpdateOnly)
	paramValues["validate_certs"] = types.NewBoolValue(&module.Params.ValidateCerts)
	module.Params.values = paramValues

	// Create dynamic result values
	resultValues := map[string]types.Value{}

	module.Result.values = resultValues

	return &module
}

// Dnf (dnf) - Manages packages with the I(dnf) package manager
//
// Installs, upgrade, removes, and lists packages and groups with the I(dnf) package manager.
//
//
// Source: https://github.com/ansible/ansible/blob/v2.13.1/lib/ansible/modules/dnf.py
type Dnf struct {
	Params DnfParams
	Result DnfResult
}

type DnfParams struct {

	// AllowDowngrade
	// Specify if the named package and version is allowed to downgrade a maybe already installed higher version of that package. Note that setting allow_downgrade=True can make this module behave in a non-idempotent way. The task could end up with a set of packages that does not match the complete list of specified packages to install (because dependencies between the downgraded package and others can cause changes to the packages which were in the earlier transaction).
	//
	// Default: no
	// Required: false
	AllowDowngrade bool `yaml:"allow_downgrade,omitempty" json:"allow_downgrade,omitempty" cty:"allow_downgrade"`

	// Allowerasing
	// If C(yes) it allows  erasing  of  installed  packages to resolve dependencies.
	//
	// Default: no
	// Required: false
	Allowerasing bool `yaml:"allowerasing,omitempty" json:"allowerasing,omitempty" cty:"allowerasing"`

	// Autoremove
	// If C(yes), removes all "leaf" packages from the system that were originally installed as dependencies of user-installed packages but which are no longer required by any such package. Should be used alone or when state is I(absent)
	//
	// Default: no
	// Required: false
	Autoremove bool `yaml:"autoremove,omitempty" json:"autoremove,omitempty" cty:"autoremove"`

	// Bugfix
	// If set to C(yes), and C(state=latest) then only installs updates that have been marked bugfix related.
	// Note that, similar to C(dnf upgrade-minimal), this filter applies to dependencies as well.
	//
	// Default: no
	// Required: false
	Bugfix bool `yaml:"bugfix,omitempty" json:"bugfix,omitempty" cty:"bugfix"`

	// Cacheonly
	// Tells dnf to run entirely from system cache; does not download or update metadata.
	//
	// Default: no
	// Required: false
	Cacheonly bool `yaml:"cacheonly,omitempty" json:"cacheonly,omitempty" cty:"cacheonly"`

	// ConfFile
	// The remote dnf configuration file to use for the transaction.
	//
	// Default: <no value>
	// Required: false
	ConfFile string `yaml:"conf_file,omitempty" json:"conf_file,omitempty" cty:"conf_file"`

	// DisableExcludes
	// Disable the excludes defined in DNF config files.
	// If set to C(all), disables all excludes.
	// If set to C(main), disable excludes defined in [main] in dnf.conf.
	// If set to C(repoid), disable excludes defined for given repo id.
	//
	// Default: <no value>
	// Required: false
	DisableExcludes string `yaml:"disable_excludes,omitempty" json:"disable_excludes,omitempty" cty:"disable_excludes"`

	// DisableGpgCheck
	// Whether to disable the GPG checking of signatures of packages being installed. Has an effect only if state is I(present) or I(latest).
	// This setting affects packages installed from a repository as well as "local" packages installed from the filesystem or a URL.
	//
	// Default: no
	// Required: false
	DisableGpgCheck bool `yaml:"disable_gpg_check,omitempty" json:"disable_gpg_check,omitempty" cty:"disable_gpg_check"`

	// DisablePlugin
	// I(Plugin) name to disable for the install/update operation. The disabled plugins will not persist beyond the transaction.
	//
	// Default: <no value>
	// Required: false
	DisablePlugin []string `yaml:"disable_plugin,omitempty" json:"disable_plugin,omitempty" cty:"disable_plugin"`

	// Disablerepo
	// I(Repoid) of repositories to disable for the install/update operation. These repos will not persist beyond the transaction. When specifying multiple repos, separate them with a ",".
	//
	// Default: <no value>
	// Required: false
	Disablerepo []string `yaml:"disablerepo,omitempty" json:"disablerepo,omitempty" cty:"disablerepo"`

	// DownloadDir
	// Specifies an alternate directory to store packages.
	// Has an effect only if I(download_only) is specified.
	//
	// Default: <no value>
	// Required: false
	DownloadDir string `yaml:"download_dir,omitempty" json:"download_dir,omitempty" cty:"download_dir"`

	// DownloadOnly
	// Only download the packages, do not install them.
	//
	// Default: no
	// Required: false
	DownloadOnly bool `yaml:"download_only,omitempty" json:"download_only,omitempty" cty:"download_only"`

	// EnablePlugin
	// I(Plugin) name to enable for the install/update operation. The enabled plugin will not persist beyond the transaction.
	//
	// Default: <no value>
	// Required: false
	EnablePlugin []string `yaml:"enable_plugin,omitempty" json:"enable_plugin,omitempty" cty:"enable_plugin"`

	// Enablerepo
	// I(Repoid) of repositories to enable for the install/update operation. These repos will not persist beyond the transaction. When specifying multiple repos, separate them with a ",".
	//
	// Default: <no value>
	// Required: false
	Enablerepo []string `yaml:"enablerepo,omitempty" json:"enablerepo,omitempty" cty:"enablerepo"`

	// Exclude
	// Package name(s) to exclude when state=present, or latest. This can be a list or a comma separated string.
	//
	// Default: <no value>
	// Required: false
	Exclude []string `yaml:"exclude,omitempty" json:"exclude,omitempty" cty:"exclude"`

	// InstallRepoquery
	// This is effectively a no-op in DNF as it is not needed with DNF, but is an accepted parameter for feature parity/compatibility with the I(yum) module.
	//
	// Default: yes
	// Required: false
	InstallRepoquery bool `yaml:"install_repoquery,omitempty" json:"install_repoquery,omitempty" cty:"install_repoquery"`

	// InstallWeakDeps
	// Will also install all packages linked by a weak dependency relation.
	//
	// Default: yes
	// Required: false
	InstallWeakDeps bool `yaml:"install_weak_deps,omitempty" json:"install_weak_deps,omitempty" cty:"install_weak_deps"`

	// Installroot
	// Specifies an alternative installroot, relative to which all packages will be installed.
	//
	// Default: /
	// Required: false
	Installroot string `yaml:"installroot,omitempty" json:"installroot,omitempty" cty:"installroot"`

	// List
	// Various (non-idempotent) commands for usage with C(/usr/bin/ansible) and I(not) playbooks. See examples.
	//
	// Default: <no value>
	// Required: false
	List string `yaml:"list,omitempty" json:"list,omitempty" cty:"list"`

	// LockTimeout
	// Amount of time to wait for the dnf lockfile to be freed.
	//
	// Default: 30
	// Required: false
	LockTimeout int `yaml:"lock_timeout,omitempty" json:"lock_timeout,omitempty" cty:"lock_timeout"`

	// Name
	// A package name or package specifier with version, like C(name-1.0). When using state=latest, this can be '*' which means run: dnf -y update. You can also pass a url or a local path to a rpm file. To operate on several packages this can accept a comma separated string of packages or a list of packages.
	// Comparison operators for package version are valid here C(>), C(<), C(>=), C(<=). Example - C(name>=1.0)
	// You can also pass an absolute path for a binary which is provided by the package to install. See examples for more information.
	//
	// Default: <no value>
	// Required: true
	Name []string `yaml:"name,omitempty" json:"name,omitempty" cty:"name"`

	// Nobest
	// Set best option to False, so that transactions are not limited to best candidates only.
	//
	// Default: no
	// Required: false
	Nobest bool `yaml:"nobest,omitempty" json:"nobest,omitempty" cty:"nobest"`

	// Releasever
	// Specifies an alternative release from which all packages will be installed.
	//
	// Default: <no value>
	// Required: false
	Releasever string `yaml:"releasever,omitempty" json:"releasever,omitempty" cty:"releasever"`

	// Security
	// If set to C(yes), and C(state=latest) then only installs updates that have been marked security related.
	// Note that, similar to C(dnf upgrade-minimal), this filter applies to dependencies as well.
	//
	// Default: no
	// Required: false
	Security bool `yaml:"security,omitempty" json:"security,omitempty" cty:"security"`

	// SkipBroken
	// Skip all unavailable packages or packages with broken dependencies without raising an error. Equivalent to passing the --skip-broken option.
	//
	// Default: no
	// Required: false
	SkipBroken bool `yaml:"skip_broken,omitempty" json:"skip_broken,omitempty" cty:"skip_broken"`

	// Sslverify
	// Disables SSL validation of the repository server for this transaction.
	// This should be set to C(no) if one of the configured repositories is using an untrusted or self-signed certificate.
	//
	// Default: yes
	// Required: false
	Sslverify bool `yaml:"sslverify,omitempty" json:"sslverify,omitempty" cty:"sslverify"`

	// State
	// Whether to install (C(present), C(latest)), or remove (C(absent)) a package.
	// Default is C(None), however in effect the default action is C(present) unless the C(autoremove) option is enabled for this module, then C(absent) is inferred.
	//
	// Default: <no value>
	// Required: false
	State string `yaml:"state,omitempty" json:"state,omitempty" cty:"state"`

	// UpdateCache
	// Force dnf to check if cache is out of date and redownload if needed. Has an effect only if state is I(present) or I(latest).
	//
	// Default: no
	// Required: false
	UpdateCache bool `yaml:"update_cache,omitempty" json:"update_cache,omitempty" cty:"update_cache"`

	// UpdateOnly
	// When using latest, only update installed packages. Do not install packages.
	// Has an effect only if state is I(latest)
	//
	// Default: no
	// Required: false
	UpdateOnly bool `yaml:"update_only,omitempty" json:"update_only,omitempty" cty:"update_only"`

	// ValidateCerts
	// This only applies if using a https url as the source of the rpm. e.g. for localinstall. If set to C(no), the SSL certificates will not be validated.
	// This should only set to C(no) used on personally controlled sites using self-signed certificates as it avoids verifying the source site.
	//
	// Default: yes
	// Required: false
	ValidateCerts bool `yaml:"validate_certs,omitempty" json:"validate_certs,omitempty" cty:"validate_certs"`

	values map[string]types.Value
}

func (p *DnfParams) Names() []string {
	names := []string{}
	for name := range p.values {
		names = append(names, name)
	}
	return names
}

func (p *DnfParams) Set(name string, value interface{}) error {
	v, ok := p.values[name]
	if !ok {
		return fmt.Errorf("no param with name %q", name)
	}
	return v.Set(value)
}

func (p *DnfParams) Get(name string) (interface{}, error) {
	v, ok := p.values[name]
	if !ok {
		return nil, fmt.Errorf("no param with name %q", name)
	}
	return v.Get(), nil
}

type DnfResult struct {
	types.CommonReturn
	Raw string

	values map[string]types.Value
}

func (r *DnfResult) Names() []string {
	names := []string{}
	for name := range r.values {
		names = append(names, name)
	}
	return names
}

func (r *DnfResult) Set(name string, value interface{}) error {
	v, ok := r.values[name]
	if !ok {
		return fmt.Errorf("no param with name %q", name)
	}
	return v.Set(value)
}

func (r *DnfResult) Get(name string) (interface{}, error) {
	v, ok := r.values[name]
	if !ok {
		return nil, fmt.Errorf("no param with name %q", name)
	}
	return v.Get(), nil
}

func (m *Dnf) GetResult() types.Result {
	return &m.Result
}

func (m *Dnf) GetResultRaw() string {
	return m.Result.Raw
}

func (m *Dnf) GetCommonResult() types.CommonReturn {
	return m.Result.CommonReturn
}

func (m *Dnf) GetParams() types.Params {
	return &m.Params
}

func (m *Dnf) GetType() string {
	return "dnf"
}
