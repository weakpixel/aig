package module

// Autogenerated file

import (
	"fmt"
	"github.com/weakpixel/aig/pkg/types"
)

func init() {
	addModuleFactory("replace", func() types.Module {
		return NewReplace()
	})
}

//
// Replace (replace) - Replace all instances of a particular string in a file using a back-referenced regular expression
//
func NewReplace() *Replace {
	module := Replace{}
	// Create dynamic param values
	paramValues := map[string]types.Value{}
	paramValues["after"] = types.NewStringValue(&module.Params.After)
	paramValues["backup"] = types.NewBoolValue(&module.Params.Backup)
	paramValues["before"] = types.NewStringValue(&module.Params.Before)
	paramValues["encoding"] = types.NewStringValue(&module.Params.Encoding)
	paramValues["others"] = types.NewStringValue(&module.Params.Others)
	paramValues["path"] = types.NewStringValue(&module.Params.Path)
	paramValues["regexp"] = types.NewStringValue(&module.Params.Regexp)
	paramValues["replace"] = types.NewStringValue(&module.Params.Replace)
	module.Params.values = paramValues

	// Create dynamic result values
	resultValues := map[string]types.Value{}

	module.Result.values = resultValues

	return &module
}

// Replace (replace) - Replace all instances of a particular string in a file using a back-referenced regular expression
//
// This module will replace all instances of a pattern within a file.
//
// It is up to the user to maintain idempotence by ensuring that the same pattern would never match any replacements made.
//
//
// Source: https://github.com/ansible/ansible/blob/v2.13.1/lib/ansible/modules/replace.py
type Replace struct {
	Params ReplaceParams
	Result ReplaceResult
}

type ReplaceParams struct {

	// After
	// If specified, only content after this match will be replaced/removed.
	// Can be used in combination with C(before).
	// Uses Python regular expressions; see U(https://docs.python.org/3/library/re.html).
	// Uses DOTALL, which means the C(.) special character I(can match newlines).
	//
	// Default: <no value>
	// Required: false
	After string `yaml:"after,omitempty" json:"after,omitempty"`

	// Backup
	// Create a backup file including the timestamp information so you can get the original file back if you somehow clobbered it incorrectly.
	//
	// Default: no
	// Required: false
	Backup bool `yaml:"backup,omitempty" json:"backup,omitempty"`

	// Before
	// If specified, only content before this match will be replaced/removed.
	// Can be used in combination with C(after).
	// Uses Python regular expressions; see U(https://docs.python.org/3/library/re.html).
	// Uses DOTALL, which means the C(.) special character I(can match newlines).
	//
	// Default: <no value>
	// Required: false
	Before string `yaml:"before,omitempty" json:"before,omitempty"`

	// Encoding
	// The character encoding for reading and writing the file.
	//
	// Default: utf-8
	// Required: false
	Encoding string `yaml:"encoding,omitempty" json:"encoding,omitempty"`

	// Others
	// All arguments accepted by the M(ansible.builtin.file) module also work here.
	//
	// Default: <no value>
	// Required: false
	Others string `yaml:"others,omitempty" json:"others,omitempty"`

	// Path
	// The file to modify.
	// Before Ansible 2.3 this option was only usable as I(dest), I(destfile) and I(name).
	//
	// Default: <no value>
	// Required: true
	Path string `yaml:"path,omitempty" json:"path,omitempty"`

	// Regexp
	// The regular expression to look for in the contents of the file.
	// Uses Python regular expressions; see U(https://docs.python.org/3/library/re.html).
	// Uses MULTILINE mode, which means C(^) and C($) match the beginning and end of the file, as well as the beginning and end respectively of I(each line) of the file.
	// Does not use DOTALL, which means the C(.) special character matches any character I(except newlines). A common mistake is to assume that a negated character set like C([^#]) will also not match newlines.
	// In order to exclude newlines, they must be added to the set like C([^#\n]).
	// Note that, as of Ansible 2.0, short form tasks should have any escape sequences backslash-escaped in order to prevent them being parsed as string literal escapes. See the examples.
	//
	// Default: <no value>
	// Required: true
	Regexp string `yaml:"regexp,omitempty" json:"regexp,omitempty"`

	// Replace
	// The string to replace regexp matches.
	// May contain backreferences that will get expanded with the regexp capture groups if the regexp matches.
	// If not set, matches are removed entirely.
	// Backreferences can be used ambiguously like C(\1), or explicitly like C(\g<1>).
	//
	// Default: <no value>
	// Required: false
	Replace string `yaml:"replace,omitempty" json:"replace,omitempty"`

	values map[string]types.Value
}

func (p *ReplaceParams) Names() []string {
	names := []string{}
	for name := range p.values {
		names = append(names, name)
	}
	return names
}

func (p *ReplaceParams) Set(name string, value interface{}) error {
	v, ok := p.values[name]
	if !ok {
		return fmt.Errorf("no param with name %q", name)
	}
	return v.Set(value)
}

func (p *ReplaceParams) Get(name string) (interface{}, error) {
	v, ok := p.values[name]
	if !ok {
		return nil, fmt.Errorf("no param with name %q", name)
	}
	return v.Get(), nil
}

type ReplaceResult struct {
	types.CommonReturn
	Raw string

	values map[string]types.Value
}

func (r *ReplaceResult) Names() []string {
	names := []string{}
	for name := range r.values {
		names = append(names, name)
	}
	return names
}

func (r *ReplaceResult) Set(name string, value interface{}) error {
	v, ok := r.values[name]
	if !ok {
		return fmt.Errorf("no param with name %q", name)
	}
	return v.Set(value)
}

func (r *ReplaceResult) Get(name string) (interface{}, error) {
	v, ok := r.values[name]
	if !ok {
		return nil, fmt.Errorf("no param with name %q", name)
	}
	return v.Get(), nil
}

func (m *Replace) GetResult() types.Result {
	return &m.Result
}

func (m *Replace) GetResultRaw() string {
	return m.Result.Raw
}

func (m *Replace) GetCommonResult() types.CommonReturn {
	return m.Result.CommonReturn
}

func (m *Replace) GetParams() types.Params {
	return &m.Params
}

func (m *Replace) GetType() string {
	return "replace"
}
