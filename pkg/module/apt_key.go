package module

// Autogenerated file

import (
	"fmt"
	"github.com/weakpixel/aig/pkg/types"
)

func init() {
	addModuleFactory("apt_key", func() types.Module {
		return NewAptKey()
	})
}

//
// AptKey (apt_key) - Add or remove an apt key
//
func NewAptKey() *AptKey {
	module := AptKey{}
	// Create dynamic param values
	paramValues := map[string]types.Value{}
	paramValues["data"] = types.NewStringValue(&module.Params.Data)
	paramValues["file"] = types.NewStringValue(&module.Params.File)
	paramValues["id"] = types.NewStringValue(&module.Params.Id)
	paramValues["keyring"] = types.NewStringValue(&module.Params.Keyring)
	paramValues["keyserver"] = types.NewStringValue(&module.Params.Keyserver)
	paramValues["state"] = types.NewStringValue(&module.Params.State)
	paramValues["url"] = types.NewStringValue(&module.Params.Url)
	paramValues["validate_certs"] = types.NewBoolValue(&module.Params.ValidateCerts)
	module.Params.values = paramValues

	// Create dynamic result values
	resultValues := map[string]types.Value{}

	// NOT SUPPORTED: after After []map[string]interface{}
	// NOT SUPPORTED: before Before []map[string]interface{}
	resultValues["fp"] = types.NewStringValue(&module.Result.Fp)
	resultValues["id"] = types.NewStringValue(&module.Result.Id)
	resultValues["key_id"] = types.NewStringValue(&module.Result.KeyId)
	resultValues["short_id"] = types.NewStringValue(&module.Result.ShortId)
	module.Result.values = resultValues

	return &module
}

// AptKey (apt_key) - Add or remove an apt key
//
// Add or remove an I(apt) key, optionally downloading it.
//
//
// Source: https://github.com/ansible/ansible/blob/v2.13.1/lib/ansible/modules/apt_key.py
type AptKey struct {
	Params AptKeyParams
	Result AptKeyResult
}

type AptKeyParams struct {

	// Data
	// The keyfile contents to add to the keyring.
	//
	// Default: <no value>
	// Required: false
	Data string `yaml:"data,omitempty" json:"data,omitempty"`

	// File
	// The path to a keyfile on the remote server to add to the keyring.
	//
	// Default: <no value>
	// Required: false
	File string `yaml:"file,omitempty" json:"file,omitempty"`

	// Id
	// The identifier of the key.
	// Including this allows check mode to correctly report the changed state.
	// If specifying a subkey's id be aware that apt-key does not understand how to remove keys via a subkey id.  Specify the primary key's id instead.
	// This parameter is required when C(state) is set to C(absent).
	//
	// Default: <no value>
	// Required: false
	Id string `yaml:"id,omitempty" json:"id,omitempty"`

	// Keyring
	// The full path to specific keyring file in C(/etc/apt/trusted.gpg.d/).
	//
	// Default: <no value>
	// Required: false
	Keyring string `yaml:"keyring,omitempty" json:"keyring,omitempty"`

	// Keyserver
	// The keyserver to retrieve key from.
	//
	// Default: <no value>
	// Required: false
	Keyserver string `yaml:"keyserver,omitempty" json:"keyserver,omitempty"`

	// State
	// Ensures that the key is present (added) or absent (revoked).
	//
	// Default: present
	// Required: false
	State string `yaml:"state,omitempty" json:"state,omitempty"`

	// Url
	// The URL to retrieve key from.
	//
	// Default: <no value>
	// Required: false
	Url string `yaml:"url,omitempty" json:"url,omitempty"`

	// ValidateCerts
	// If C(no), SSL certificates for the target url will not be validated. This should only be used on personally controlled sites using self-signed certificates.
	//
	// Default: yes
	// Required: false
	ValidateCerts bool `yaml:"validate_certs,omitempty" json:"validate_certs,omitempty"`

	values map[string]types.Value
}

func (p *AptKeyParams) Names() []string {
	names := []string{}
	for name := range p.values {
		names = append(names, name)
	}
	return []string{}
}

func (p *AptKeyParams) Set(name string, value interface{}) error {
	v, ok := p.values[name]
	if !ok {
		return fmt.Errorf("no param with name %q", name)
	}
	return v.Set(value)
}

func (p *AptKeyParams) Get(name string) (interface{}, error) {
	v, ok := p.values[name]
	if !ok {
		return nil, fmt.Errorf("no param with name %q", name)
	}
	return v.Get(), nil
}

type AptKeyResult struct {
	types.CommonReturn
	Raw string

	// After
	// List of apt key ids or fingerprints after any modification
	After []map[string]interface{} `yaml:"after,omitempty" json:"after,omitempty"`

	// Before
	// List of apt key ids or fingprints before any modifications
	Before []map[string]interface{} `yaml:"before,omitempty" json:"before,omitempty"`

	// Fp
	// Fingerprint of the key to import
	Fp string `yaml:"fp,omitempty" json:"fp,omitempty"`

	// Id
	// key id from source
	Id string `yaml:"id,omitempty" json:"id,omitempty"`

	// KeyId
	// calculated key id, it should be same as 'id', but can be different
	KeyId string `yaml:"key_id,omitempty" json:"key_id,omitempty"`

	// ShortId
	// caclulated short key id
	ShortId string `yaml:"short_id,omitempty" json:"short_id,omitempty"`

	values map[string]types.Value
}

func (r *AptKeyResult) Names() []string {
	names := []string{}
	for name := range r.values {
		names = append(names, name)
	}
	return []string{}
}

func (r *AptKeyResult) Set(name string, value interface{}) error {
	v, ok := r.values[name]
	if !ok {
		return fmt.Errorf("no param with name %q", name)
	}
	return v.Set(value)
}

func (r *AptKeyResult) Get(name string) (interface{}, error) {
	v, ok := r.values[name]
	if !ok {
		return nil, fmt.Errorf("no param with name %q", name)
	}
	return v.Get(), nil
}

func (m *AptKey) GetResult() types.Result {
	return &m.Result
}

func (m *AptKey) GetResultRaw() string {
	return m.Result.Raw
}

func (m *AptKey) GetCommonResult() types.CommonReturn {
	return m.Result.CommonReturn
}

func (m *AptKey) GetParams() types.Params {
	return &m.Params
}

func (m *AptKey) GetType() string {
	return "apt_key"
}
