package module

// Autogenerated file

import (
	"fmt"
	"github.com/weakpixel/aig/pkg/types"
)

func init() {
	addModuleFactory("blockinfile", func() types.Module {
		return NewBlockinfile()
	})
}

//
// Blockinfile (blockinfile) - Insert/update/remove a text block surrounded by marker lines
//
func NewBlockinfile() *Blockinfile {
	module := Blockinfile{}
	// Create dynamic param values
	paramValues := map[string]types.Value{}
	paramValues["backup"] = types.NewBoolValue(&module.Params.Backup)
	paramValues["block"] = types.NewStringValue(&module.Params.Block)
	paramValues["create"] = types.NewBoolValue(&module.Params.Create)
	paramValues["insertafter"] = types.NewStringValue(&module.Params.Insertafter)
	paramValues["insertbefore"] = types.NewStringValue(&module.Params.Insertbefore)
	paramValues["marker"] = types.NewStringValue(&module.Params.Marker)
	paramValues["marker_begin"] = types.NewStringValue(&module.Params.MarkerBegin)
	paramValues["marker_end"] = types.NewStringValue(&module.Params.MarkerEnd)
	paramValues["path"] = types.NewStringValue(&module.Params.Path)
	paramValues["state"] = types.NewStringValue(&module.Params.State)
	module.Params.values = paramValues

	// Create dynamic result values
	resultValues := map[string]types.Value{}

	module.Result.values = resultValues

	return &module
}

// Blockinfile (blockinfile) - Insert/update/remove a text block surrounded by marker lines
//
// This module will insert/update/remove a block of multi-line text surrounded by customizable marker lines.
//
//
// Source: https://github.com/ansible/ansible/blob/v2.13.1/lib/ansible/modules/blockinfile.py
type Blockinfile struct {
	Params BlockinfileParams
	Result BlockinfileResult
}

type BlockinfileParams struct {

	// Backup
	// Create a backup file including the timestamp information so you can get the original file back if you somehow clobbered it incorrectly.
	//
	// Default: no
	// Required: false
	Backup bool `yaml:"backup,omitempty" json:"backup,omitempty" cty:"backup"`

	// Block
	// The text to insert inside the marker lines.
	// If it is missing or an empty string, the block will be removed as if C(state) were specified to C(absent).
	//
	// Default:
	// Required: false
	Block string `yaml:"block,omitempty" json:"block,omitempty" cty:"block"`

	// Create
	// Create a new file if it does not exist.
	//
	// Default: no
	// Required: false
	Create bool `yaml:"create,omitempty" json:"create,omitempty" cty:"create"`

	// Insertafter
	// If specified and no begin/ending C(marker) lines are found, the block will be inserted after the last match of specified regular expression.
	// A special value is available; C(EOF) for inserting the block at the end of the file.
	// If specified regular expression has no matches, C(EOF) will be used instead.
	//
	// Default: EOF
	// Required: false
	Insertafter string `yaml:"insertafter,omitempty" json:"insertafter,omitempty" cty:"insertafter"`

	// Insertbefore
	// If specified and no begin/ending C(marker) lines are found, the block will be inserted before the last match of specified regular expression.
	// A special value is available; C(BOF) for inserting the block at the beginning of the file.
	// If specified regular expression has no matches, the block will be inserted at the end of the file.
	//
	// Default: <no value>
	// Required: false
	Insertbefore string `yaml:"insertbefore,omitempty" json:"insertbefore,omitempty" cty:"insertbefore"`

	// Marker
	// The marker line template.
	// C({mark}) will be replaced with the values in C(marker_begin) (default="BEGIN") and C(marker_end) (default="END").
	// Using a custom marker without the C({mark}) variable may result in the block being repeatedly inserted on subsequent playbook runs.
	//
	// Default: # {mark} ANSIBLE MANAGED BLOCK
	// Required: false
	Marker string `yaml:"marker,omitempty" json:"marker,omitempty" cty:"marker"`

	// MarkerBegin
	// This will be inserted at C({mark}) in the opening ansible block marker.
	//
	// Default: BEGIN
	// Required: false
	MarkerBegin string `yaml:"marker_begin,omitempty" json:"marker_begin,omitempty" cty:"marker_begin"`

	// MarkerEnd
	// This will be inserted at C({mark}) in the closing ansible block marker.
	//
	// Default: END
	// Required: false
	MarkerEnd string `yaml:"marker_end,omitempty" json:"marker_end,omitempty" cty:"marker_end"`

	// Path
	// The file to modify.
	// Before Ansible 2.3 this option was only usable as I(dest), I(destfile) and I(name).
	//
	// Default: <no value>
	// Required: true
	Path string `yaml:"path,omitempty" json:"path,omitempty" cty:"path"`

	// State
	// Whether the block should be there or not.
	//
	// Default: present
	// Required: false
	State string `yaml:"state,omitempty" json:"state,omitempty" cty:"state"`

	values map[string]types.Value
}

func (p *BlockinfileParams) Names() []string {
	names := []string{}
	for name := range p.values {
		names = append(names, name)
	}
	return names
}

func (p *BlockinfileParams) Set(name string, value interface{}) error {
	v, ok := p.values[name]
	if !ok {
		return fmt.Errorf("no param with name %q", name)
	}
	return v.Set(value)
}

func (p *BlockinfileParams) Get(name string) (interface{}, error) {
	v, ok := p.values[name]
	if !ok {
		return nil, fmt.Errorf("no param with name %q", name)
	}
	return v.Get(), nil
}

type BlockinfileResult struct {
	types.CommonReturn
	Raw string

	values map[string]types.Value
}

func (r *BlockinfileResult) Names() []string {
	names := []string{}
	for name := range r.values {
		names = append(names, name)
	}
	return names
}

func (r *BlockinfileResult) Set(name string, value interface{}) error {
	v, ok := r.values[name]
	if !ok {
		return fmt.Errorf("no param with name %q", name)
	}
	return v.Set(value)
}

func (r *BlockinfileResult) Get(name string) (interface{}, error) {
	v, ok := r.values[name]
	if !ok {
		return nil, fmt.Errorf("no param with name %q", name)
	}
	return v.Get(), nil
}

func (m *Blockinfile) GetResult() types.Result {
	return &m.Result
}

func (m *Blockinfile) GetResultRaw() string {
	return m.Result.Raw
}

func (m *Blockinfile) GetCommonResult() types.CommonReturn {
	return m.Result.CommonReturn
}

func (m *Blockinfile) GetParams() types.Params {
	return &m.Params
}

func (m *Blockinfile) GetType() string {
	return "blockinfile"
}
