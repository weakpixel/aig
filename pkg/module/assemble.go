package module

// Autogenerated file

import (
	"fmt"
	"github.com/weakpixel/aig/pkg/types"
)

func init() {
	addModuleFactory("assemble", func() types.Module {
		return NewAssemble()
	})
}

//
// Assemble (assemble) - Assemble configuration files from fragments
//
func NewAssemble() *Assemble {
	module := Assemble{}
	// Create dynamic param values
	paramValues := map[string]types.Value{}
	paramValues["backup"] = types.NewBoolValue(&module.Params.Backup)
	paramValues["delimiter"] = types.NewStringValue(&module.Params.Delimiter)
	paramValues["dest"] = types.NewStringValue(&module.Params.Dest)
	paramValues["ignore_hidden"] = types.NewBoolValue(&module.Params.IgnoreHidden)
	paramValues["regexp"] = types.NewStringValue(&module.Params.Regexp)
	paramValues["remote_src"] = types.NewBoolValue(&module.Params.RemoteSrc)
	paramValues["src"] = types.NewStringValue(&module.Params.Src)
	paramValues["validate"] = types.NewStringValue(&module.Params.Validate)
	module.Params.values = paramValues

	// Create dynamic result values
	resultValues := map[string]types.Value{}

	module.Result.values = resultValues

	return &module
}

// Assemble (assemble) - Assemble configuration files from fragments
//
// Assembles a configuration file from fragments.
//
// Often a particular program will take a single configuration file and does not support a C(conf.d) style structure where it is easy to build up the configuration from multiple sources. C(assemble) will take a directory of files that can be local or have already been transferred to the system, and concatenate them together to produce a destination file.
//
// Files are assembled in string sorting order.
//
// Puppet calls this idea I(fragments).
//
//
// Source: https://github.com/ansible/ansible/blob/v2.13.1/lib/ansible/modules/assemble.py
type Assemble struct {
	Params AssembleParams
	Result AssembleResult
}

type AssembleParams struct {

	// Backup
	// Create a backup file (if C(yes)), including the timestamp information so you can get the original file back if you somehow clobbered it incorrectly.
	//
	// Default: no
	// Required: false
	Backup bool `yaml:"backup,omitempty" json:"backup,omitempty"`

	// Delimiter
	// A delimiter to separate the file contents.
	//
	// Default: <no value>
	// Required: false
	Delimiter string `yaml:"delimiter,omitempty" json:"delimiter,omitempty"`

	// Dest
	// A file to create using the concatenation of all of the source files.
	//
	// Default: <no value>
	// Required: true
	Dest string `yaml:"dest,omitempty" json:"dest,omitempty"`

	// IgnoreHidden
	// A boolean that controls if files that start with a '.' will be included or not.
	//
	// Default: no
	// Required: false
	IgnoreHidden bool `yaml:"ignore_hidden,omitempty" json:"ignore_hidden,omitempty"`

	// Regexp
	// Assemble files only if C(regex) matches the filename.
	// If not set, all files are assembled.
	// Every "\" (backslash) must be escaped as "\\" to comply to YAML syntax.
	// Uses L(Python regular expressions,https://docs.python.org/3/library/re.html).
	//
	// Default: <no value>
	// Required: false
	Regexp string `yaml:"regexp,omitempty" json:"regexp,omitempty"`

	// RemoteSrc
	// If C(no), it will search for src at originating/master machine.
	// If C(yes), it will go to the remote/target machine for the src.
	//
	// Default: yes
	// Required: false
	RemoteSrc bool `yaml:"remote_src,omitempty" json:"remote_src,omitempty"`

	// Src
	// An already existing directory full of source files.
	//
	// Default: <no value>
	// Required: true
	Src string `yaml:"src,omitempty" json:"src,omitempty"`

	// Validate
	// The validation command to run before copying into place.
	// The path to the file to validate is passed in via '%s' which must be present as in the sshd example below.
	// The command is passed securely so shell features like expansion and pipes won't work.
	//
	// Default: <no value>
	// Required: false
	Validate string `yaml:"validate,omitempty" json:"validate,omitempty"`

	values map[string]types.Value
}

func (p *AssembleParams) Names() []string {
	names := []string{}
	for name := range p.values {
		names = append(names, name)
	}
	return names
}

func (p *AssembleParams) Set(name string, value interface{}) error {
	v, ok := p.values[name]
	if !ok {
		return fmt.Errorf("no param with name %q", name)
	}
	return v.Set(value)
}

func (p *AssembleParams) Get(name string) (interface{}, error) {
	v, ok := p.values[name]
	if !ok {
		return nil, fmt.Errorf("no param with name %q", name)
	}
	return v.Get(), nil
}

type AssembleResult struct {
	types.CommonReturn
	Raw string

	values map[string]types.Value
}

func (r *AssembleResult) Names() []string {
	names := []string{}
	for name := range r.values {
		names = append(names, name)
	}
	return names
}

func (r *AssembleResult) Set(name string, value interface{}) error {
	v, ok := r.values[name]
	if !ok {
		return fmt.Errorf("no param with name %q", name)
	}
	return v.Set(value)
}

func (r *AssembleResult) Get(name string) (interface{}, error) {
	v, ok := r.values[name]
	if !ok {
		return nil, fmt.Errorf("no param with name %q", name)
	}
	return v.Get(), nil
}

func (m *Assemble) GetResult() types.Result {
	return &m.Result
}

func (m *Assemble) GetResultRaw() string {
	return m.Result.Raw
}

func (m *Assemble) GetCommonResult() types.CommonReturn {
	return m.Result.CommonReturn
}

func (m *Assemble) GetParams() types.Params {
	return &m.Params
}

func (m *Assemble) GetType() string {
	return "assemble"
}
