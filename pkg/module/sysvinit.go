package module

// Autogenerated file

import (
	"fmt"
	"github.com/weakpixel/aig/pkg/types"
)

func init() {
	addModuleFactory("sysvinit", func() types.Module {
		return NewSysvinit()
	})
}

//
// Sysvinit (sysvinit) - Manage SysV services.
//
func NewSysvinit() *Sysvinit {
	module := Sysvinit{}
	// Create dynamic param values
	paramValues := map[string]types.Value{}
	paramValues["arguments"] = types.NewStringValue(&module.Params.Arguments)
	paramValues["daemonize"] = types.NewBoolValue(&module.Params.Daemonize)
	paramValues["enabled"] = types.NewBoolValue(&module.Params.Enabled)
	paramValues["name"] = types.NewStringValue(&module.Params.Name)
	paramValues["pattern"] = types.NewStringValue(&module.Params.Pattern)
	paramValues["runlevels"] = types.NewStringArrayValue(&module.Params.Runlevels)
	paramValues["sleep"] = types.NewIntValue(&module.Params.Sleep)
	paramValues["state"] = types.NewStringValue(&module.Params.State)
	module.Params.values = paramValues

	// Create dynamic result values
	resultValues := map[string]types.Value{}

	module.Result.values = resultValues

	return &module
}

// Sysvinit (sysvinit) - Manage SysV services.
//
// Controls services on target hosts that use the SysV init system.
//
//
// Source: https://github.com/ansible/ansible/blob/v2.13.1/lib/ansible/modules/sysvinit.py
type Sysvinit struct {
	Params SysvinitParams
	Result SysvinitResult
}

type SysvinitParams struct {

	// Arguments
	// Additional arguments provided on the command line that some init scripts accept.
	//
	// Default: <no value>
	// Required: false
	Arguments string `yaml:"arguments,omitempty" json:"arguments,omitempty"`

	// Daemonize
	// Have the module daemonize as the service itself might not do so properly.
	// This is useful with badly written init scripts or daemons, which commonly manifests as the task hanging as it is still holding the tty or the service dying when the task is over as the connection closes the session.
	//
	// Default: no
	// Required: false
	Daemonize bool `yaml:"daemonize,omitempty" json:"daemonize,omitempty"`

	// Enabled
	// Whether the service should start on boot. B(At least one of state and enabled are required.)
	//
	// Default: <no value>
	// Required: false
	Enabled bool `yaml:"enabled,omitempty" json:"enabled,omitempty"`

	// Name
	// Name of the service.
	//
	// Default: <no value>
	// Required: true
	Name string `yaml:"name,omitempty" json:"name,omitempty"`

	// Pattern
	// A substring to look for as would be found in the output of the I(ps) command as a stand-in for a status result.
	// If the string is found, the service will be assumed to be running.
	// This option is mainly for use with init scripts that don't support the 'status' option.
	//
	// Default: <no value>
	// Required: false
	Pattern string `yaml:"pattern,omitempty" json:"pattern,omitempty"`

	// Runlevels
	// The runlevels this script should be enabled/disabled from.
	// Use this to override the defaults set by the package or init script itself.
	//
	// Default: <no value>
	// Required: false
	Runlevels []string `yaml:"runlevels,omitempty" json:"runlevels,omitempty"`

	// Sleep
	// If the service is being C(restarted) or C(reloaded) then sleep this many seconds between the stop and start command. This helps to workaround badly behaving services.
	//
	// Default: 1
	// Required: false
	Sleep int `yaml:"sleep,omitempty" json:"sleep,omitempty"`

	// State
	// C(started)/C(stopped) are idempotent actions that will not run commands unless necessary. Not all init scripts support C(restarted) nor C(reloaded) natively, so these will both trigger a stop and start as needed.
	//
	// Default: <no value>
	// Required: false
	State string `yaml:"state,omitempty" json:"state,omitempty"`

	values map[string]types.Value
}

func (p *SysvinitParams) Names() []string {
	names := []string{}
	for name := range p.values {
		names = append(names, name)
	}
	return []string{}
}

func (p *SysvinitParams) Set(name string, value interface{}) error {
	v, ok := p.values[name]
	if !ok {
		return fmt.Errorf("no param with name %q", name)
	}
	return v.Set(value)
}

func (p *SysvinitParams) Get(name string) (interface{}, error) {
	v, ok := p.values[name]
	if !ok {
		return nil, fmt.Errorf("no param with name %q", name)
	}
	return v.Get(), nil
}

type SysvinitResult struct {
	types.CommonReturn
	Raw string

	// Results
	// results from actions taken
	Results interface{} `yaml:"results,omitempty" json:"results,omitempty"`

	values map[string]types.Value
}

func (r *SysvinitResult) Names() []string {
	names := []string{}
	for name := range r.values {
		names = append(names, name)
	}
	return []string{}
}

func (r *SysvinitResult) Set(name string, value interface{}) error {
	v, ok := r.values[name]
	if !ok {
		return fmt.Errorf("no param with name %q", name)
	}
	return v.Set(value)
}

func (r *SysvinitResult) Get(name string) (interface{}, error) {
	v, ok := r.values[name]
	if !ok {
		return nil, fmt.Errorf("no param with name %q", name)
	}
	return v.Get(), nil
}

func (m *Sysvinit) GetResult() types.Result {
	return &m.Result
}

func (m *Sysvinit) GetResultRaw() string {
	return m.Result.Raw
}

func (m *Sysvinit) GetCommonResult() types.CommonReturn {
	return m.Result.CommonReturn
}

func (m *Sysvinit) GetParams() types.Params {
	return &m.Params
}

func (m *Sysvinit) GetType() string {
	return "sysvinit"
}
